# 被动技能设计逻辑

1. 触发时间。常见的有，当xxx的时候，执行yyy的逻辑。触发条件，是一块逻辑。

   ![img](../image/v2-0e11647285b5b3ce3ca49b5512b37b37_720w.jpg)

2. **触发前置条件。**例如，当xxx时，***有20%概率\***执行yyy逻辑。当触发，并达成一定条件的时候，才执行yyy。

   ![img](../image/v2-3729c43e8c4871404530afa9dc4d102e_720w.jpg)

3. **执行的具体逻辑。**就是当xxx时，执行yyy，这里，我整体抽象yyy为buffer，分为持续性buffer和瞬时的buffer。![img](../image/v2-4d18382258c15f6145c6b8edaeb635e3_720w.jpg)

4. **对什么人添加buffer（执行操作），即目标选择。**例如，当xxx时，***对半径内敌人\***，执行yyy。

   ![img](../image/v2-6507e70b866be714d8542a62e9df43b0_720w.jpg)

5. **对目标的过滤。**例如，当xxx时，对半径内***血量大于50%\***的敌人，执行yyy。

   ![img](../image/v2-39cbf549a3448bf8145a60f9efd5d908_720w.jpg)

6. **buffer 的叠加类型。**例如，火焰buff，可叠加xxx层。

   ![img](../image/v2-26625ca8038c0d629c9638d99d4061d4_720w.jpg)

7. **数值类buff的数值类型。**例如给玩家增加攻击，防御，暴击率等等。

   ![img](../image/v2-6d64209b9e855540a5a09b4765dea5f3_720w.jpg)

8. **数值来源。**例如，增加***当前攻击力10%的\***防御力。数值可能是需要根据条件计算出来的

   ![img](../image/v2-ff30c692c5ed42ce302a5065b3dd20ac_720w.jpg)

   数值来源这里，可以考虑小部分来自脚本公式。但是我们还是选择处理少量数特殊需求。

9. **buffer 的生效条件。**例如，添加一个buff，持续10秒，过程中，***当血量低于10%\***，提升暴击率50%。这种一般是，一个持续性buff，需要某些条件下，才生效。

   ![img](../image/v2-e2b431700e1fe0c18c197050c10def7b_720w.jpg)

**通过上述的分析，我们基本上可以在结构上还原出需求。根据细分的模块，根据需求添加模块的点，然后策划通过编辑器去组合各个模块，就可以得到需求的效果。后续的扩展，就是主要对以上几个模块的分别扩展。**

## **大体的数据结构（数据class关系），分为被动技能，和buffer两大部分**

1. **被动技能部分**

   ![img](../image/v2-9a171b80349720403ae9b6b618bbd330_720w.jpg)

   PassiveSkillCfg：一个被动技能的根，包含多个事件的配置

   PassiveSkillEventCfg_base：一个事件的配置，包含多个前置条件，以及条件达成后触发什么（通常是添加buffer和添加其他被动事件）

   ![img](../image/v2-05641ff3a5614ea01ce1da65750c77ef_720w.jpg)

   PassiveSkillEventPreConditionCfg_base：各种不同的前置条件

   ![img](../image/v2-18e302c263c7cd43453ac5abbbbf7374_720w.jpg)

2.  **buffer部分**

   ![img](../image/v2-45a00ad802f4e231154fc717807c6a92_720w.jpg)

   BufferCfg_base：buffer类型

   ![img](../image/v2-2a34b80366a583b9617df298b62addd7_720w.jpg)

   ![img](../image/v2-112004142414e87f072cb445e7df984b_720w.jpg)

   SelectTargetCfg：选择目标

   ![img](../image/v2-b73cc479e58a2952c1affc5fb02de729_720w.jpg)

   SelectTargetFilter_base：选择目标过滤

   ![img](../image/v2-0a564de8aa51a933b831fa7ebc797ef3_720w.jpg)

   我们以设置数值buffer举例

   ![img](../image/v2-96339a113c1c69263a4fc359f0033cf5_720w.jpg)

   BufferSetValueType：buffer改变的数值类型

   BufferValueSourceCfg_Base：数据来源

![img](../image/v2-ba30a3bd445b1037882f0943d84b6019_720w.jpg)

BufferValidCfg_base：buffer的生效条件

![img](../image/v2-190309915e979894084c0aa36752cbec_720w.jpg)

每种buffer的逻辑可能不同，根据配置不同的数据，处理不同的逻辑即可，非常方便扩展。

![img](../image/v2-7eb3f081ae9b385492e4ab919aec1aa4_b.webp)

**以上基本就是整体的思路，主要就是根据逻辑，在语义上，研究划分，将需求划分成每一个块，每一个块可以单独扩展，之后将逻辑整合起来，策划通过编辑器去组合不同的模块逻辑。**

这里之所以说我们要在语义上划分，是因为，如果我们按别的方式去抽象逻辑，策划配置的时候，可能需要一个思维转换的过程。而在语义上划分的话，策划基本是根据他们自己定义的描述（就像他们给出的需求描述），一步一步在编辑器里去配置，在思维上，是顺畅的。

我们的代码设计和编辑器，还是有很多做得不够好的地方，并且根据策划的需求，经过了几次重构和整理，才有了现在的结构。

## **在Excel表里，配置数据，编辑器里，配置逻辑**

在最初的设计，我考虑漏了一点，就是如何在excel里面配置数值，编辑器配置逻辑，将两者分离。当策划提出被动技能和buffer需要升级，例如cd，数值，条件的数值等等，各个数值部分都可能会变，这时候如何配置，1~10级的数值，但是逻辑一样，总不能复制10个出来吧。

后面我们的补救措施（为了兼容之前的配置），是在excel里面，配置每一个buffer id对应的逻辑id（即编辑器里面的逻辑），然后配置1~20个数值参数（20够用了）。

编辑器里面，配置数值的地方，配置1~20的参数索引，初始化的时候，读取配置的数值。

![img](https://pic2.zhimg.com/80/v2-49601fd46693361572c4d71f452bf98d_720w.jpg)配置1~20的参数索引

这个处理方式不是太优雅，如果重新设计，可能专门设计一个数值类，可以选择直接设置，还是读取配置。当前有点积重难返，暂时这样处理了，也能解决问题。

## 总结

借助之前做技能编辑器的经验，我们直接使用了protobuf来序列化配置，并借助Advanced Inspector这个插件来处理配置的UI界面。因为不需要显示角色模型等，我们用EditorWindow的方式来做被动技能和buffer的编辑器。