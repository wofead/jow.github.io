



# 技能框架

[toc]

游戏的基本框架是ECS框架，所以在游戏中，都是通过系统来驱动技能的，从触发到执行，一致到添加Buff结束。

技能框架主要包含：

1. Trigger
2. Skill
3. Behavior
4. Buff

这四个部分，其中Trigger绑定在实体身上，根据事件和相应的条件来触发，当触发了触发器之后，开始释放技能，一般技能包含一系列的行为，行为是按顺序执行的，一个执行完之后开始执行下一个行为，每个行为包含一系列的Buff，buff中包含buffMethod这个就是用来改变实体状态的最终方式。

## 触发器

游戏中的触发器分为两种，一种是无条件事件触发，另一种就是有条件事件触发。

无条件触发意思就是一个事件过来的，只要是实体上存在监听这个事件的触发器，这个触发器就触发成功，有条件的意思就是，就算是遇到了这个事件，条件也要满足才能够触发。

在游戏中，Trigger最关键的几个字段就是Condition，Skill和Delay，Delay的意思是延迟触发的意思。

其中Condition是触发条件，在游戏中这个触发条件都是通用的，一般配置方式是触发事件加参数`Sensor(1)|SensorStay(1)`，可以配置多个可触发条件，满足其中一个就可以触发。

所以在这里先创建一个Condition Group来封装这些条件：

```lua
-- @Author: Jax
-- @Date:   2020-05-14 11:14:28
local LuaClass = LuaClass
local super = nil
---@class TriggerConditionGroup
local TriggerConditionGroup = class("TriggerConditionGroup", super)

---@param str string
---@param trigger SkillTrigger@
function TriggerConditionGroup:ctor(str, trigger)
    ---@type table<number, BaseTriggerCondition[]>
    self.conditions = {}
    if str == -1 or str == "-1" then
        return
    end
    local tempStr = string.split(str, '|')
    local eventName
    for _, temp in ipairs(tempStr) do
        local cmd, params = self:_parseCmd(temp)
        local conditionType = LuaClass.FightEnum.TriggerType[cmd]
        --判断是否存在这个类型
        if not conditionType then
            print("TriggerCondition not find <<   " .. cmd .."   >>str:" ..str)
            error("TriggerCondition not find")
        else
            ---@type BaseTriggerCondition
            local cond
            eventName = cmd .. "TriggerCondition"
            if LuaClassList[string.lower(eventName)] then
                cond = LuaClass[eventName](params)
            else
                cond = LuaClass.EventTriggerCondition()
            end
            cond.paramStr = temp
            if cond then
                cond.trigger = trigger
            end
            self.conditions[conditionType] = self.conditions[conditionType] or {}
            table.insert(self.conditions[conditionType], cond)
        end
    end
end

function TriggerConditionGroup:_parseCmd(str)
    if not string.match(str, ".*%(.*%)$") then
        error("函数格式错误,检查是否有中文括号 " .. str)
    end

    local condStr = string.gsub(str, "%)", "")
    local condArr = string.split(condStr, "(")
    local cmd = condArr[1]
    local params = string.splitNumber(condArr[2], ",")
    return cmd, params
end

function TriggerConditionGroup:check(entity, event)
    --printJow("TriggerConditionGroup:check ", entity:dump(), event, self.conditions)
    local eventName = event[1]
    if not eventName then
        print("event = ", event)
        error("TriggerConditionGroup not find event ", event)
    end
    local condArr = self.conditions[eventName]
    if not condArr then
        return false
    end

    for _, condition in ipairs(condArr) do
        if #event == 1 then
            if condition:check(entity) then
                return true
            end
        else
            if condition:check(entity, table.unpack(event, 2)) then
                return true
            end
        end
    end

    return false
end

function TriggerConditionGroup:hasEvent(name)
    return self.conditions[name] ~= nil
end

return TriggerConditionGroup
```
所有的条件判断都在condition group中进行判断，成功true，失败false。

```lua
-- @Author: jow
-- @Date:   2020/5/12 10:40

local LuaClass = LuaClass
local super = nil
---@class BaseTriggerCondition
local BaseTriggerCondition = class("BaseTriggerCondition", super)

---@field trigger SkillTrigger
local greater = function (a, b)
    return a > b
end

local equal = function (a, b)
    return a == b
end

local less = function (a, b)
    return a < b
end

local greaterEqual = function (a, b)
    return a >= b
end

local anyRound = function ()
    return true
end

local lessEqual = function (a, b)
    return a <= b
end

local mod = function(a, b, c)
    return a % b == c
end

local add = function(a, b)
    a = a or 0
    return a + b
end

local sub = function(a, b)
    a = a or 0
    return a - b
end

local mul = function(a, b)
    a = a or 1
    return a * b
end

local div = function(a, b)
    a = a or 0
    return a / b
end

local eval = function(a, b)
    return b
end

local compareFuncConfig = { }
compareFuncConfig[1] = equal
compareFuncConfig[2] = greaterEqual
compareFuncConfig[3] = greater
compareFuncConfig[4] = lessEqual
compareFuncConfig[5] = less
compareFuncConfig[6] = anyRound
compareFuncConfig[7] = mod

compareFuncConfig["=="] = equal
compareFuncConfig[">="] = greaterEqual
compareFuncConfig[">"] = greater
compareFuncConfig["<="] = lessEqual
compareFuncConfig["<"] = less
compareFuncConfig["#"] = anyRound
compareFuncConfig["%"] = mod
compareFuncConfig["+"] = add
compareFuncConfig["-"] = sub
compareFuncConfig["*"] = mul
compareFuncConfig["/"] = div
compareFuncConfig["="] = eval


---@field trigger SkillTrigger
function BaseTriggerCondition:ctor(params)
    self._params = params
    self:setParams(params)
end

function BaseTriggerCondition:setParams(params)
    
end

---@param e EcsEntity
function BaseTriggerCondition:check(e, ...)
    return false
end

function BaseTriggerCondition:getCompareFunc(ntype)
    return compareFuncConfig[ntype]
end

--function BaseTriggerCondition.getCompareFunction(ntype)
--    return compareFuncConfig[ntype]
--end

return BaseTriggerCondition
```

游戏中的带参数的触发器，需要建立类来进行参数检测，而不带参数的直接放到一个string数组中就可以了，创建类的时候使用通用模板。

```lua
-- @Author: Jax
-- @Date:   2020-05-07 16:26:38
local LuaClass = LuaClass
local super = LuaClass.BaseTriggerCondition
---@class EventTriggerCondition:BaseTriggerCondition
local EventTriggerCondition = class("EventTriggerCondition", super)

function EventTriggerCondition:setParams()
end


function EventTriggerCondition:check(e, params)
    return true
end

return EventTriggerCondition
```

其它的根据具体的类名来创建condition。

```lua
-- @Author: Jax
-- @Date:   2020-06-19 17:38:08
local LuaClass = LuaClass
local super = LuaClass.BaseTriggerCondition
---@class SensorTriggerCondition:BaseTriggerCondition
local SensorTriggerCondition = class("SensorTriggerCondition", super)

function SensorTriggerCondition:setParams(params)
    self.triggerIds = string.split(params[1], ';')
end

---@param e EcsEntity
function SensorTriggerCondition:check(e, id)
    --if self.uniteTypes[1] == "All" then
    --    return true
    --end
    id = id .. ""

    return table.indexof(self.triggerIds, id) > 0
end

return SensorTriggerCondition
```

## Trigger System

一个system存在的意义在于逐帧执行一些事情，如果Trigger是立即触发的，不需要延时触发其实就没有必要存在System，但是特殊情况下Trigger是需要延时触发的，这个时候就需要System来执行了。

在触发之前我们需要知道，究竟那里来统一处理触发器的，这里一般都是放在实体身上，使用实体身上的一个方法：

```lua
---@param event number
function EcsEntity:triggerSkill(event)
    if not self.skillTrigger then
        return
    end

    local triggerList = self.triggerEventIndex:getSkillTriggers(event[1])
    if not triggerList or #triggerList == 0 then
        return
    end

    --- 移除Trigger
    local len = #triggerList
    for i = len, 1, -1 do
        if triggerList[i].removeConditionGroup and triggerList[i].removeConditionGroup:check(self, event) then
            self:removeSkillTrigger(triggerList[i])
        end
    end

    --事件为key，值为SkillTriggerTable
    if #triggerList == 0 then
        --不存在可以触发的技能
        return false
    end

    ---@type SkillTrigger[]
    local copyTriggers = nil
    for _, trigger in ipairs(triggerList) do
        if trigger:checkSkillConditionByEvent(self, event) then
            copyTriggers = copyTriggers or table.create()
            table.insert(copyTriggers, trigger)
        end
    end

    if copyTriggers then
        for _, trigger in ipairs(copyTriggers) do
            --printJow("EcsEntityExtensions", trigger.skillTriggerTemplateVO.ID, event)
            if trigger:getDelayFrame() > 0 then
                ---@type TimeComponent
                local time = self._owner:getUniqueComponent(LuaClass.TimeComponent)
                if not self.skillTriggerDelay then
                    self:set(LuaClass.SkillTriggerDelayComponent)
                end
                self.skillTriggerDelay:addHandler(trigger:getDelayFrame() + time.frame, trigger)
            else
                --self:handleSKillList(triggerSkillList)
                trigger:triggerSkill(self)
            end
            table.insert(self.skillTrigger.curFrameExecute, trigger.skillTriggerTemplateVO.ID)
            self:addTriggerEvent(LuaClass.FightEnum.TriggerType.SkillTrigger, trigger.skillTriggerTemplateVO.ID)
            if trigger:canRemove() then
                self.skillTrigger:removeTrigger(trigger)
            end
        end
        table.release(copyTriggers)
    end
end
```

在这里涉及到一个Component，是触发事件索引的组件：

```lua
--------------------------------------------
-- Author: Jax
-- Date: 2020/12/31 11:37
-- Desc: 
---------------------------------------------
local LuaClass = LuaClass
local super = LuaClass.EcsComponent
---@class TriggerEventIndexComponent:EcsComponent
local TriggerEventIndexComponent = class("TriggerEventIndexComponent", super)

function TriggerEventIndexComponent:set(value)
    self.value = value
end

function TriggerEventIndexComponent:hasEvent(name)
    local arr
    for _, v in pairs(self.value) do
        arr = v[name]
        if arr and #arr > 0 then
            return true
        end
    end
    return false
end

---@return SkillTrigger[]
function TriggerEventIndexComponent:getSkillTriggers(eventName)
    if self.value[LuaClass.SkillTrigger.__cname] then
        return self.value[LuaClass.SkillTrigger.__cname][eventName]
    end
end

function TriggerEventIndexComponent:getBuffTriggers(eventName)
    if self.value[LuaClass.Buff.__cname] then
        return self.value[LuaClass.Buff.__cname][eventName]
    end
end

---@param conditionGroup TriggerConditionGroup
function TriggerEventIndexComponent:addQuickIndex(obj, conditionGroup)
    if not conditionGroup then
        return
    end
    local arr, events
    for key, _ in pairs(conditionGroup.conditions) do
        local clsName = obj.__cname
        if not self.value[clsName] then
            self.value[clsName] = {}
        end
        arr = self.value[clsName]
        if not arr[key] then
            arr[key] = {}
        end
        events = arr[key]
        table.insert(events, obj)
    end
end

---@param conditionGroup TriggerConditionGroup
function TriggerEventIndexComponent:removeQuickIndex(obj, conditionGroup)
    if not conditionGroup then
        return
    end
    local arr, events
    for key, _ in pairs(conditionGroup.conditions) do
        local clsName = obj.__cname
        if not self.value[clsName] then
            self.value[clsName] = {}
        end
        arr = self.value[clsName]
        if not arr[key] then
            arr[key] = {}
        end
        events = arr[key]
        table.removebyvalue(events, obj)
    end
end

return TriggerEventIndexComponent
```

这个组件可以帮助快速的找到要判断的触发器，然后进行判断是否触发，还是加入到延时触发组件中。

```lua
-- @Author: jow
-- @Date:   2020/7/30 14:44
-- @Des:    轮询SkillTrigger，触发技能
local LuaClass = LuaClass
local super = nil
---@class SkillTriggerSystem
local SkillTriggerSystem = class("SkillTriggerSystem", super)

---@param world EcsWorld
function SkillTriggerSystem:ctor(world)
    self.world = world
    self.delayFilter = self.world:getFilter({ LuaClass.SkillTriggerDelayComponent })
end

function SkillTriggerSystem:execute()
    ---@type TimeComponent
    local time = self.world:getUniqueComponent(LuaClass.TimeComponent)
    for _, e in ipairs(self.delayFilter.entities) do
        local handlers = e.skillTriggerDelay.value[time.frame]
        if handlers then
            ---@param trigger SkillTrigger
            for _, trigger in ipairs(handlers) do
                if not e:isStun() or trigger.skillTriggerTemplateVO.StunApply == 1 then
                    trigger:triggerSkill(e)
                end
            end
            e.skillTriggerDelay:removeHandler(time.frame)
        end
    end
end

return SkillTriggerSystem

```

## SkillTrigger类

```lua
-- @Author: jow
-- @Date:   2020/5/7 14:56

local LuaClass = LuaClass
local super = nil
---@class SkillTrigger
local SkillTrigger = class("SkillTrigger", super)

function SkillTrigger:ctor(skillTriggerId)
    self.skillTriggerTemplateVO = LuaClass.SkillTriggerDatatable:getByID(skillTriggerId)
    if not self.skillTriggerTemplateVO then
        error("不存在这个SkillTriggerId：" .. skillTriggerId)
    end
    self.skillIds = self.skillTriggerTemplateVO.Skill
    -- 操作触发条件
    ---@type TriggerConditionGroup
    self.conditionGroup = LuaClass.TriggerConditionGroup(self.skillTriggerTemplateVO.Condition, self)

    -- 操作触发条件
    ---@type TriggerConditionGroup
    self.removeConditionGroup = LuaClass.TriggerConditionGroup(self.skillTriggerTemplateVO.RemoveCondition, self)

    self.variableConditionParams = LuaClass.SkillTriggerDatatable:getVariableCondition(skillTriggerId)

    self.delay = self.skillTriggerTemplateVO.Delay
    --已经触发的次数
    self.triggerCount = 0

    ---回合触发次数
    self.currentRoundCount = 0
    ---一场战斗触发次数
    self.currentBattleCount = 0
end

---@param event number @modify  entity
---@param entity EcsEntity @modify  entity
function SkillTrigger:checkSkillConditionByEvent(entity, event)
    if not self:hasUseCount() or not self:checkVariable(entity) then
        return false
    end

    if self.skillTriggerTemplateVO.StunApply ~= 1 and entity:isStun() then
        --- 昏迷
        return false
    end

    if self.conditionGroup:check(entity, event) then
        
        printSkillLog("SkillTrigger Trigger success: ", entity.category.value, entity.id, self.skillTriggerTemplateVO.ID, self.skillTriggerTemplateVO.VariableConditionSet)
        --self:changeVariable(entity)
        self.triggerCount = self.triggerCount + 1
        self.currentRoundCount = self.currentRoundCount + 1
        self.currentBattleCount = self.currentBattleCount + 1
        return true
    else
        return false
    end
end

---@param entity EcsEntity
function SkillTrigger:checkVariable(entity)
    --print(variables[1] == "-1",variables[1])
    if not isValidValue(self.variableConditionParams) then
        return true
    end

    if not entity.variable then
        return false
    end

    local variableValue, compareFunc
    for _, param in ipairs(self.variableConditionParams) do
        variableValue = entity.variable:getValue(param.name)
        if variableValue == nil then
            return false
        end
        compareFunc = LuaClass.BaseTriggerCondition:getCompareFunc(param.operation)
        if not compareFunc(variableValue, param.value) then
            return false
        end
    end
    return true
end

function SkillTrigger:getDelayFrame()
    local frame = 0
    if self.delay ~= -1 then
        frame = math.ceil(self.delay / GameConfig.LockedTimeStep)
    end
    return frame
end

function SkillTrigger:hasUseCount()
    return (self.skillTriggerTemplateVO.RoundCount == -1 or self.skillTriggerTemplateVO.RoundCount > self.currentRoundCount) and (self.skillTriggerTemplateVO.BattleCount == -1 or self.skillTriggerTemplateVO.BattleCount > self.currentBattleCount)
end

function SkillTrigger:canRemove()
    return self.skillTriggerTemplateVO.BattleCount ~= -1 and self.skillTriggerTemplateVO.BattleCount - self.triggerCount <= 0
end

---@return string[]
function SkillTrigger:getSkillIds()
    return self.skillIds
end

---@param entity EcsEntity
function SkillTrigger:triggerSkill(entity)
    ---@param skillId number
    for _, skillId in ipairs(self.skillIds) do
        --local skill = LuaClass.Skill()
        --skill:_init(skillId, self._owner)
        ---@type Skill
        local skill = LuaClass.Skill.Pool:get(skillId, entity._owner, self.skillTriggerTemplateVO.ID)

        App.battleInfoManager:recordAddSkill(skill,entity)

        skill:activateSkill(entity)
        skill:executeBehavior(entity)

        if not skill.isFinish then
            entity.skill:addSkill(skill)
        else
            LuaClass.Skill.Pool:add(skill)
        end

        if entity.motion then
            entity.motion:onSkillUse(skillId)
        end
    end
end

return SkillTrigger
```

这里我们主要关注最后一个函数`triggerSkill`,在这里我们激活skill并且执行里面的行为。

## Skill

skill里面放了一系列的行为，当行为执行完成之后，代表着这个skill执行完成。

```lua
-- @Author: jow
-- @Date:   2020/5/7 14:57

local LuaClass = LuaClass
local super = nil
---@class Skill
local Skill = class("Skill", super)

Skill.Pool = LuaClass.ObjectPool(
    function ()
        return LuaClass.Skill()
    end,
    function (obj, ...)
        obj:init(...)
    end,
    function (obj)
        obj:reset()
    end
)

function Skill:ctor()
    ---@type SkillBehavior[]
    self._behaviorList = {}
end

---@param world EcsWorld
---@param skillTrigger SkillTrigger
function Skill:init(skillId, world, skillTriggerId)
    self.world = world
    self.skillTemplateVO = LuaClass.SkillDatatable:getByID(skillId)
    self.skillTriggerId = skillTriggerId
    self.uid = LuaClass.BattleInfoManager.getUID()

    local behaviorId = self.skillTemplateVO.Behavior
    ---@type SkillBehavior
    local behavior
    while isValidValue(behaviorId) do
        --behavior = LuaClass.SkillBehavior(behaviorId, self)
        behavior = LuaClass.SkillBehavior.Pool:get(behaviorId, self)
        table.insert(self._behaviorList, behavior)

        if isValidValue(behavior.behaviorTemplateVO.NextBehavior) then
            local tempArr = behavior.behaviorTemplateVO.NextBehavior
            local total = 0
            for _, v in ipairs(tempArr) do
                total = total + v.value
            end
            local randomValue = self.world.random:Next(1, total)
            for _, v in ipairs(tempArr) do
                randomValue = randomValue - v.value
                if randomValue <= 0 then
                    behaviorId = v.ID
                    break
                end
            end
        else
            break
        end
    end
    self.curBehaviorIndex = 1
    self.isFinish = false
    self._isActive = false
    self.animStateSkilling = false
end

function Skill:reset()
    while #self._behaviorList ~= 0 do
        local behavior = table.remove(self._behaviorList)
        LuaClass.SkillBehavior.Pool:add(behavior)
    end
end

function Skill:executeBehavior(entity)
    --if self.skillTemplateVO.ID == 108 then
    --    printJow("Skill30062", "30062")
    --end

    local curBehavior = self._behaviorList[self.curBehaviorIndex]
    while curBehavior do
        curBehavior:execute(entity)
        if curBehavior.isFinish then
            self.curBehaviorIndex = self.curBehaviorIndex + 1
            curBehavior = self._behaviorList[self.curBehaviorIndex]
        else
            break
        end
    end

    if not curBehavior then
        self._isActive = false
        self.isFinish = true

        self:changeVariableSkillOver(entity)

        --if self.skillTemplateVO.ID == 30062 then
        --    printJow("Skill", "30062", "30062isFinish")
        --end
    end
end

---@param entity EcsEntity
function Skill:replaceSkillGroup(entity)
    if not isValidValue(self.skillTemplateVO.SkillGroup) then
        return
    end
    ---@type Skill[]
    local skillList = entity.skill.value
    for _, skill in ipairs(skillList) do
        if skill.skillTemplateVO.SkillGroup == self.skillTemplateVO.SkillGroup then
            skill._isActive = false
            skill.isFinish = true
        end
    end
end

function Skill:activateSkill(entity)
    self._isActive = true

    self:replaceSkillGroup(entity)
    self:changeVariableSkillStart(entity)
end

function Skill:isActive()
    return self._isActive
end

function Skill:setAnimStateSkilling(value)
    self.animStateSkilling = value
end

---@param entity EcsEntity
function Skill:changeVariableSkillStart(entity)
    if not isValidValue(self.skillTriggerId) then
        return
    end
    local param = LuaClass.SkillTriggerDatatable:getSkillStartVariableConditionSet(self.skillTriggerId)
    self:changeVariable(entity, param)

    App.battleInfoManager:recordSkillStart(self,entity)
end

---@param entity EcsEntity
function Skill:changeVariableSkillOver(entity)
    if not isValidValue(self.skillTriggerId) then
        return
    end
    local param = LuaClass.SkillTriggerDatatable:getSkillOverVariableConditionSet(self.skillTriggerId)
    self:changeVariable(entity, param)

    App.battleInfoManager:recordSkillOver(self,entity)
end

---@param entity EcsEntity
function Skill:changeVariable(entity, paramSet)
    --if self.skillTriggerTemplateVO.ID == 30013 then
    --    printJow("SkillTrigger", "30013")
    --end

    if not isValidValue(paramSet) then
        return
    end

    if not entity.variable then
        entity:set(LuaClass.VariableComponent)
    end

    local operFunc,value
    local variableComponent = entity.variable
    for _, param in ipairs(paramSet) do
        operFunc = LuaClass.BaseTriggerCondition:getCompareFunc(param.operation)
        if param.operation == "#" then
            local min, max = table.unpack(string.splitNumber(param.value, ';'))
            value = entity._owner.random:Next(min, max)
            variableComponent:setValue(param.name, value)
        elseif operFunc then
            value = operFunc(variableComponent:getValue(param.name), param.value)
            variableComponent:setValue(param.name, value)
        else
            error("not find operation skillStartVariableConditionSet = " .. self.skillTriggerId)
        end
    end
end

return Skill
```

## Skill System

在技能中，行为是可以持续执行的，所有需要一个系统来驱动这个行为。

```lua
-- @Author: jow
-- @Date:   2020/5/7 14:56

local LuaClass = LuaClass
local super = nil
---@class SkillSystem
local SkillSystem = class("SkillSystem", super)

---@param world EcsWorld
function SkillSystem:ctor(world)
    self.world = world
    self.filter = world:getFilter({ LuaClass.SkillComponent })
end

function SkillSystem:execute()
    ---@param e EcsEntity
    for _, e in ipairs(self.filter.entities) do
        local skills = e.skill.value
        ---@type Skill[]
        local copySkillList = table.create()
        table.insertto(copySkillList, skills)
        for _, skill in ipairs(copySkillList) do
            if skill:isActive() then
                skill:executeBehavior(e)
            end
            if skill.isFinish then
                e.skill:removeSkill(skill)
                LuaClass.Skill.Pool:add(skill)
            end
        end
        table.release(copySkillList)
    end
end

return SkillSystem
```

## Skill Behavior

实体做一个行为是一个很复杂的过程，它一般包含开始执行行为，行为执行多久，以及一个打击目标事件。

一般在执行一个行为有开始一个行为，更新行为作用的实体，行为生效，添加buff。

在获取行为生效的实体是，经过一系列的筛选得到需要行为去作用的实体。

```lua
-- @Author: Jax
-- @Date:   2020-06-29 18:20:50

local LuaClass = LuaClass
local super = nil
---@class SkillBehavior
---@field _hitShape TrueSync.Physics2D.Collision.Shapes.PolygonShape|TrueSync.Physics2D.Collision.Shapes.CircleShape
local SkillBehavior = class("SkillBehavior", super)

SkillBehavior.Pool = LuaClass.ObjectPool(
        function()
            return LuaClass.SkillBehavior()
        end,
        function(obj, behaviorId, skill)
            obj:init(behaviorId, skill)
        end,
        function(obj)
            obj:reset()
        end
)

function SkillBehavior:ctor()
    self.addBuffList = {}
    self.actEntityIds = {}
    self.actEntityIdHash = {}
end

---@param skill Skill
function SkillBehavior:init(behaviorId, skill)
    --if behaviorId == 320421 then
    --    printJow("SkillBehavior", "320421")
    --end
    self._behaviorId = behaviorId
    self._skill = skill
    self.world = skill.world

    local fb = table.create(LuaClass.PlayerInfoComponent, LuaClass.NpcComponent, LuaClass.BreakObjectComponent)
    local no = table.create(LuaClass.DestroyedComponent)
    self.filter = self.world:getFilter(nil, fb, no)
    table.release(fb)
    table.release(no)

    self.behaviorTemplateVO = LuaClass.BehaviorDatatable:getByID(behaviorId)
    if self.behaviorTemplateVO == nil then
        error("BehaviorId is wrong " .. behaviorId)
    end
    if self.behaviorTemplateVO.TakeEffectTime > 0 then
        self._effectFrame = math.ceil(self.behaviorTemplateVO.TakeEffectTime / GameConfig.LockedTimeStep)
    else
        self._effectFrame = 0
    end
    if self.behaviorTemplateVO.Duration > 0 then
        self._durationFrame = math.ceil(self.behaviorTemplateVO.Duration / GameConfig.LockedTimeStep)
    else
        self._durationFrame = 0
    end
    if self.behaviorTemplateVO.HitTime > 0 then
        self._hitFrame = math.ceil(self.behaviorTemplateVO.HitTime / GameConfig.LockedTimeStep) + self._effectFrame
    else
        self._hitFrame = 0
    end
    self._isPlaying = false
    self._isEffecting = false
    self.isFinish = false
    self._continuedFrame = 0
end

function SkillBehavior:reset()
    table.clear(self.addBuffList)
    table.clear(self.actEntityIds)
    table.clear(self.actEntityIdHash)

    if isValid(self._hitShape) then
        self.world.physicsWorldMgr:returnShape(self._hitShape)
    end
    self._hitShape = nil
    self.world = nil
    self.filter = nil
end

---@param entity EcsEntity
function SkillBehavior:execute(entity)
    --if self.behaviorTemplateVO.ID == 99090343 then
    --    local aa = 0
    --end
    if self.isFinish then
        return
    end

    if self._continuedFrame >= 0 and not self._isPlaying then
        printSkillLog("SkillBehavior execute: ", self.behaviorTemplateVO.ID, entity.category.value, entity.id)
        self:startBehavior(entity)
    end

    if self._hitFrame > self._continuedFrame and self._isEffecting then
        self:updateEntities(entity)
    end

    if self._continuedFrame >= self._effectFrame and not self._isEffecting then
        self:effectBehavior(entity)
        self:createBehaviorEffect(entity)
    end

    if self._isEffecting then
        local duration = (self._continuedFrame - self._effectFrame) * GameConfig.LockedTimeStep
        local buffSpacing = self.behaviorTemplateVO.BuffSpacing
        local shouldAddBuffNum
        if buffSpacing == 0 then
            shouldAddBuffNum = #self.actEntityIds
        else
            if duration % buffSpacing == 0 then
                shouldAddBuffNum = math.ceil(duration / buffSpacing) + 1
            else
                shouldAddBuffNum = 0
            end
        end
        if shouldAddBuffNum > self.buffCount then
            shouldAddBuffNum = self.buffCount
        end
        local addLength = shouldAddBuffNum - self.hasAddedNumber
        if addLength >= 1 then
            for i = 1, addLength do
                self:addBuffAccordingToBuffSpacing(entity)
            end
        end
    end
    --持续时长和行为前摇
    if self._continuedFrame >= self._durationFrame then
        self:finish(entity)
    end
    self._continuedFrame = self._continuedFrame + 1
end

---@param entity EcsEntity
function SkillBehavior:startBehavior(entity)
    self._isPlaying = true
    ---@type EcsEntity
    self._owner = entity
    ---@type EcsEntity
    --播放实体的动画标签
    local stateLabel = self.behaviorTemplateVO.StateLabel
    if string.isValidString(stateLabel) then
        -- printJax("LuaClass.EntityEvent.SetAnimatorState", stateLabel)
        -- self._motionType = entity.motion.motionType
        -- entity.motion.motionType = LuaClass.FightEnum.MotionType.None
        self._skill:setAnimStateSkilling(true)
        self.world:notifyEvent(LuaClass.EntityEvent.SetAnimatorState, entity, stateLabel)
        self.world:notifyEvent(LuaClass.EntityEvent.SetAnimatorState, entity, "skilling", true)
    end
end

---@param entity EcsEntity
function SkillBehavior:effectBehavior(entity)
    if self.behaviorTemplateVO.ID == 99090342 then
        printJow("SkillBehavior", "300621")
    end
    App.battleInfoManager:recordBehaviorExecute(self,entity)

    if string.isValidString(self.behaviorTemplateVO.ScreenShake) then
        self.world:notifyEvent(LuaClass.EntityEvent.Shake, self.behaviorTemplateVO.ScreenShake)
    end

    self._isEffecting = true
    local buffIds = self.behaviorTemplateVO.BuffID
    if not isValidValue(buffIds) then
        self.buffCount = 0
        self.hasAddedNumber = 0
        return
    end

    --需要添加buff的对象
    local actEntities = table.create()
    self:getActEntities(entity, actEntities)
    for _, e in ipairs(actEntities) do
        table.insert(self.actEntityIds, e.id)
        self.actEntityIdHash[e.id] = e
    end
    table.release(actEntities)

    if self.behaviorTemplateVO.BuffCount == -1 then
        self.buffCount = #self.actEntityIds
    else
        self.buffCount = self.behaviorTemplateVO.BuffCount
    end
    self.hasAddedNumber = 0

end

---@param entity EcsEntity@针对于hittime，更新一下，看看是否存在需要添加的实体
function SkillBehavior:updateEntities(entity)
    local actEntities = table.create()
    self:getActEntities(entity, actEntities)
    self:filterEntities(actEntities)
    table.release(actEntities)
end

function SkillBehavior:filterEntities(entities)
    for _, e in ipairs(entities) do
        if not self.actEntityIdHash[e.id] then
            table.insert(self.actEntityIds, e.id)
            self.actEntityIdHash[e.id] = e
        end
    end
    if self.behaviorTemplateVO.BuffCount == -1 then
        self.buffCount = #self.actEntityIds
    end
end

---@param entity EcsEntity
function SkillBehavior:createBehaviorEffect(entity)
    for _, templateId in ipairs(self.behaviorTemplateVO.BehaviorEffect) do
        self.world:createEffect(entity.id, templateId)
    end
end

---@param entity EcsEntity
function SkillBehavior:addBuffAccordingToBuffSpacing(entity)
    local buffIds = self.behaviorTemplateVO.BuffID
    if not isValidValue(buffIds) then
        return
    end

    local index = self.hasAddedNumber
    index = (index % #self.actEntityIds) + 1
    local target = self:getNextEffectEntity(self.world, self.actEntityIds, index)
    if not target then
        return
    end

    -- 添加打击特效
    self:createHitEffect(entity, target)

    self.hasAddedNumber = self.hasAddedNumber + 1

    local randomValue = self.world.random:Next(1, 100)
    if self.behaviorTemplateVO.ID == 110111 then
        printZZQ("SkillBehavior", randomValue, self.behaviorTemplateVO.BuffProbability)
    end
    if randomValue <= self.behaviorTemplateVO.BuffProbability then
        for _, buffId in ipairs(buffIds) do
            target:addBuff(buffId, entity)
        end
        App.battleInfoManager:recordAddBuff(buffIds,self,entity,target)
    end
end

---@param caster EcsEntity
---@param target EcsEntity
function SkillBehavior:createHitEffect(caster, target)
    local hitPoint

    ---@type EffectGroupTempVO[]
    local effectGroup
    for _, groupId in ipairs(self.behaviorTemplateVO.HitEffectGroup) do
        effectGroup = LuaClass.EffectGroupDatatable:getGroup(groupId) or table.empty
        for _, effect in ipairs(effectGroup) do
            if effect.TargetTag == -1 or effect.TargetTag == target.template.value.EffectTag then
                if not hitPoint then
                    hitPoint = LuaClass.TSVector2.pop()
                    self:getHitPoint(caster, target, hitPoint)
                end
                self.world:createEffect(target.id, effect.EffectID, true, hitPoint)
            end
        end
    end

    if hitPoint then
        LuaClass.TSVector2.push(hitPoint)
        hitPoint = nil
    end
end

---@param caster EcsEntity
---@param target EcsEntity
---@param hitPoint TrueSync.TSVector2
function SkillBehavior:getHitPoint(caster, target, hitPoint)
    local pos = LuaClass.TSVector2.pop()
    local degree = LuaClass.FP.pop()

    local casterPos = LuaClass.Vector2.pop()
    caster.transform.position:ToVector2(casterPos)
    local hitType = self.behaviorTemplateVO.HitParameter[1]
    if hitType == 1 then
        hitPoint:Set(target.transform.position)
    elseif hitType == 2 or hitType == 3 or hitType == 5 then
        pos:SetNumber(self._hitPosX, self._hitPosY)
        degree:Set(self._hitDegree)
        LuaClass.FSHelper.Clip(pos, degree, self._hitShape, target.physicsBody.value, casterPos, hitPoint)
    elseif hitType == 4 then
        LuaClass.FSHelper.Clip(caster.physicsBody.value, target.physicsBody.value, casterPos, hitPoint)
    elseif hitType == 6 then
        local arr = table.create()
        caster.collider:getFixtures(self.behaviorTemplateVO.HitParameter[2], arr)
        if #arr == 1 then
            LuaClass.FSHelper.Clip(arr[1], target.physicsBody.value, hitPoint)
        else
            LuaClass.FSHelper.Clip(arr, target.physicsBody.value, hitPoint)
        end

        table.release(arr)
    else
        hitPoint:Set(target.transform.position)
    end

    LuaClass.TSVector2.push(pos)
    LuaClass.FP.push(degree)
    LuaClass.Vector2.push(casterPos)
end

---@param entity EcsEntity
---@param buffId number
---@return Buff
---检查当前实体身上是否存在相同ID的buff,并返回这个Buff对象
function SkillBehavior:checkExistBuff(entity, buffId)
    if not entity.buff then
        return
    end
    for _, buff in ipairs(entity.buff.value) do
        if buff.buffId == buffId and not buff.isFinish then
            return buff
        end
    end
    return nil
end

---@param actEntityIds string[]
---@param world EcsWorld
---@return EcsEntity
function SkillBehavior:getNextEffectEntity(world, actEntityIds, index)
    local target
    for i, entityId in ipairs(actEntityIds) do
        local e = world:getEntity(entityId)
        if e then
            if i < index and not target then
                target = e
            elseif i >= index then
                return e
            end
        end
    end
    return target
end

---@param entity EcsEntity @释放技能的主体
---@param result EcsEntity[] 接受结果
function SkillBehavior:getActEntities(entity, result)
    local arr = table.create()
    self:getHitRangeEntities(entity, arr)
    for _, target in ipairs(arr) do
        if self:filterByTargetType(entity, target) and
                self:filterByCamp(entity, target) and
                self:filterByBuffLabel(entity, target) then
            result[#result + 1] = target
        end
    end

    self:sortEntities(result, entity)
    self:getLimitEntities(result, entity)


    if #result == 0 then
        print(string.format("行为【%s】没有找到对象!!!", self.behaviorTemplateVO.ID))
        App.battleInfoManager:recordBehaviorNoTarget(self,entity)
    end
    table.release(arr)
    return result
end

---@param e EcsEntity
---@return EcsEntity[]
function SkillBehavior:getHitRangeEntities(e, entities)
    local hitParams = self.behaviorTemplateVO.HitParameter
    local hitType = hitParams[1]

    local func = self["_filterByHitType" .. hitType]
    if func then
        func(self, e, entities)
    else
        error("不支持的 hitType = " .. hitType .. ", behaviorId = " .. self.behaviorTemplateVO.ID)
    end

    return entities
end

---@param e EcsEntity
function SkillBehavior:_findAllPartNpc(e, entities)
    if not e then return end
    local owner = e
    if table.indexof(entities, owner) > 0 then
        return
    end
    table.insert(entities, owner)
    if owner:has(LuaClass.PartNpcListComponent) then
        local arr = e:get(LuaClass.PartNpcListComponent).value
        for _, childId in ipairs(arr) do
            local child = self.world:getEntity(childId)
            self:_findAllPartNpc(child, entities)
        end
    end
end

---@param e EcsEntity
function SkillBehavior:_findAllPartAndFollowNpc(e, entities)
    if not e then return end
    local owner = e
    if table.indexof(entities, owner) > 0 then
        return
    end
    table.insert(entities, owner)
    if owner:has(LuaClass.PartNpcListComponent) then
        local arr = e:get(LuaClass.PartNpcListComponent).value
        for _, childId in ipairs(arr) do
            local child = self.world:getEntity(childId)
            self:_findAllPartAndFollowNpc(child, entities)
        end
    end
    if owner:has(LuaClass.FollowListComponent) then
        local arr = e:get(LuaClass.FollowListComponent).value
        for _, childId in ipairs(arr) do
            local child = self.world:getEntity(childId)
            self:_findAllPartAndFollowNpc(child, entities)
        end
    end
end

---@param e EcsEntity
---@param entities EcsEntity[]
function SkillBehavior:_filterByHitType1(e, entities)
    local hitParams = self.behaviorTemplateVO.HitParameter
    for i = 2, #hitParams do
        if hitParams[i] == -4 then
            self:_findAllPartNpc(e, entities)
            for j = #entities, 1, -1 do
                if not entities[j].partNpc then
                    table.remove(entities, j)
                end
            end
        elseif hitParams[i] == -3 then
            self:_findAllPartAndFollowNpc(e, entities)
        elseif hitParams[i] == -2 then
            self:_findAllPartNpc(e, entities)
        elseif hitParams[i] == -1 then
            table.insert(entities, e)
        elseif hitParams[i] == 0 then
            if e.partNpc and e.owner then
                local owner = self.world:getLiving(e.owner.entityId)
                if owner then
                    table.insert(entities, owner)
                end
            end
        else
            if e:has(LuaClass.PartNpcListComponent) then
                local arr = e:get(LuaClass.PartNpcListComponent).value
                if hitParams[i] > #arr then
                    error("子怪id 超出范围")
                end
                local child = self.world:getLiving(arr[hitParams[i]])
                if child then
                    table.insert(entities, child)
                end
            end
        end
    end
end

---@param e EcsEntity
function SkillBehavior:_filterByHitType2(e, entities)
    local vertices = table.create()
    vertices[1] = LuaClass.TSVector2.pop()
    vertices[2] = LuaClass.TSVector2.pop()
    vertices[3] = LuaClass.TSVector2.pop()
    vertices[4] = LuaClass.TSVector2.pop()

    local hitParams = self.behaviorTemplateVO.HitParameter
    local x, y, w, h = table.unpack(hitParams, 2)
    w = math.min(w, 900000)
    h = math.min(h, 900000)
    vertices[1]:SetNumber(x, y)
    vertices[2]:SetNumber(x + w, y)
    vertices[3]:SetNumber(x + w, y + h)
    vertices[4]:SetNumber(x, y + h)

    local rotate = LuaClass.FP.pop()
    if self.behaviorTemplateVO.Rotate == 1 then
        --保证打击圈和速度方向一致
        LuaClass.TSVector2.Angle(e.velocity.value, rotate)
    else
        --保证打几圈和朝向一致
        if e.direction and e.direction.value == -1 then
            vertices[1]:SetNumber(-x, y)
            vertices[2]:SetNumber(-(x + w), y)
            vertices[3]:SetNumber(-(x + w), y + h)
            vertices[4]:SetNumber(-x, y + h)
        end
    end

    for i = 1, #vertices do
        LuaClass.TSVector2.Multiply(vertices[i], LuaClass.FP.EN2, vertices[i])
    end

    local polygon = LuaClass.FSHelper.polygonShapePool:Get()
    polygon:Set(vertices)
    for _, entity in ipairs(self.filter.entities) do
        if self.world:shapeCollide(polygon, e.transform.position, rotate, entity.physicsBody.value, self.behaviorTemplateVO.HitParameterType) then
            table.insert(entities, entity)
        end
    end
    --local polygon = e._owner.physicsWorldMgr:createPolygonShape(vertices)
    --local arr = e._owner:polygonCastAll(e.transform.position, rotate, polygon, false)
    --if arr then
    --    table.insertto(entities, arr)
    --end
    self:createHitArea(e, e.transform.position, rotate, polygon)

    for i = 1, #vertices do
        LuaClass.TSVector2.push(vertices[i])
    end
    LuaClass.FP.push(rotate)
    table.release(vertices)
end

---@param e EcsEntity
function SkillBehavior:_filterByHitType3(e, entities)
    local hitParams = self.behaviorTemplateVO.HitParameter
    local x, y, r = table.unpack(hitParams, 2)
    r = math.min(r, 900000)
    local pos = LuaClass.TSVector2.pop()
    local radius = LuaClass.FP.pop()
    radius:Set(r)
    LuaClass.FP.FastMul(radius, LuaClass.FP.EN2, radius)
    local rotate = LuaClass.FP.pop()
    if self.behaviorTemplateVO.Rotate == 1 then
        LuaClass.TSVector2.Angle(e.velocity.value, rotate)
    else
        if e.direction and e.direction.value == -1 then
            pos:SetNumber(-x, y)
        end
    end
    LuaClass.TSVector2.Multiply(pos, LuaClass.FP.EN2, pos)
    LuaClass.TSVector2.Rotate(pos, rotate, pos)
    LuaClass.TSVector2.Add(pos, e.transform.position, pos)

    --local arr = e._owner:circleCastAll(pos, radius)
    --if arr then
    --    table.insertto(entities, arr)
    --end
    --printJow("SkillBehavior _filterByHitType3", self.behaviorTemplateVO.ID, pos, radius:AsInt(), #arr)
    --local shape = e._owner.physicsWorldMgr:createCircleShape(radius, LuaClass.TSVector2.zero)
    ---@type TrueSync.Physics2D.Collision.Shapes.CircleShape
    local shape = LuaClass.FSHelper.circleShapePool:Get()
    shape:SetOrigin(LuaClass.TSVector2.zero, radius)
    shape.Position = LuaClass.TSVector2.zero
    shape.Radius = radius
    for _, entity in ipairs(self.filter.entities) do
        if self.world:shapeCollide(shape, pos, rotate, entity.physicsBody.value, self.behaviorTemplateVO.HitParameterType) then
            table.insert(entities, entity)
        end
    end

    self:createHitArea(e, pos, rotate, shape)

    LuaClass.TSVector2.push(pos)
    LuaClass.FP.push(radius)
    LuaClass.FP.push(rotate)
end

---@param e EcsEntity
function SkillBehavior:_filterByHitType4(e, entities)
    --- 碰撞列表
    local entityIds = e.collider:getCollisionEntityIds()
    local tempEntity
    for _, id in ipairs(entityIds) do
        tempEntity = e._owner:getLiving(id)
        if tempEntity then
            table.insert(entities, tempEntity)
        end
    end
end

---@param e EcsEntity
function SkillBehavior:_filterByHitType5(e, entities)
    --扇形碰撞区域
    local hitParams = self.behaviorTemplateVO.HitParameter
    local x, y, r, startAngleNum, offsetAngleNum = table.unpack(hitParams, 2)
    local pos = LuaClass.TSVector2.pop()
    local radius = LuaClass.FP.pop()
    local startAngle = LuaClass.FP.pop()
    local offsetAngle = LuaClass.FP.pop()
    pos:SetNumber(x, y)
    radius:Set(r)
    startAngle:Set(startAngleNum)
    offsetAngle:Set(offsetAngleNum)
    LuaClass.FP.FastMul(radius, LuaClass.FP.EN2, radius)

    local rotate = LuaClass.FP.pop()
    if self.behaviorTemplateVO.Rotate == 1 then
        LuaClass.TSVector2.Angle(e.velocity.value, rotate)
    else
        if e.direction and e.direction.value == -1 then
            pos:SetNumber(-x, y)
        end
    end
    LuaClass.TSVector2.Multiply(pos, LuaClass.FP.EN2, pos)
    LuaClass.TSVector2.Rotate(pos, rotate, pos)
    LuaClass.TSVector2.Add(pos, e.transform.position, pos)

    local a = LuaClass.FP.pop()
    a:Set(GameConfig.HitAreaSectorAngle)
    local polygon = LuaClass.FSHelper.polygonShapePool:Get()
    self.world.physicsWorldMgr:createPolygonShapeOfSector(radius, startAngle, offsetAngle, a, polygon)
    --local arr = e._owner:polygonCastAll(pos, rotate, polygon, false)
    --if arr then
    --    table.insertto(entities, arr)
    --end
    for _, entity in ipairs(self.filter.entities) do
        if self.world:shapeCollide(polygon, pos, rotate, entity.physicsBody.value, self.behaviorTemplateVO.HitParameterType) then
            table.insert(entities, entity)
        end
    end

    self:createHitArea(e, pos, rotate, polygon)

    LuaClass.TSVector2.push(pos)
    LuaClass.FP.push(radius)
    LuaClass.FP.push(rotate)
    LuaClass.FP.push(startAngle)
    LuaClass.FP.push(offsetAngle)
    LuaClass.FP.push(a)
end

---@param e EcsEntity
function SkillBehavior:_filterByHitType6(e, entities)
    local entityDic = table.create()
    local tempEntity
    local hitParams = self.behaviorTemplateVO.HitParameter
    for i = 2, #hitParams do
        local entityIds = e.collider:getTriggerCollisionEntityIds(hitParams[i])
        for _, entityId in ipairs(entityIds) do
            if not entityDic[entityId] then
                entityDic[entityId] = true
                tempEntity = e._owner:getLiving(entityId)
                if tempEntity then
                    table.insert(entities, tempEntity)
                end
            end
        end
    end

    --if self.behaviorTemplateVO.ID == 10000010 and #entities == 0 then
    --    local entityIds = e.collider:getTriggerCollisionEntityIds(2)
    --    UnityPause()
    --end

    table.release(entityDic)
end

---@param e EcsEntity
function SkillBehavior:_filterByHitType7(e, entities)
    local tempEntity = e._owner:getLiving(e.owner.entityId)
    if tempEntity then
        table.insert(entities, tempEntity)
    end
end

---@param e EcsEntity
---@param pos TrueSync.TSVector2
---@param rotation TrueSync.FP
function SkillBehavior:createHitArea(e, pos, rotation, shape)
    if GameConfig.UNITY_EDITOR then
        local hitArea = e._owner:createHitArea(pos, rotation, shape)
        e._owner:notifyEvent(LuaClass.EntityEvent.CreateHitArea, hitArea.id)
    end

    self._hitPosX = pos.xNumber
    self._hitPosY = pos.yNumber
    self._hitDegree = rotation:AsFloat()
    self._hitShape = shape
end

---@param caster EcsEntity
---@param target EcsEntity
function SkillBehavior:filterByCamp(caster, target)
    local campScreen = self.behaviorTemplateVO.CampScreen
    if not isValidValue(campScreen) or isNumber(campScreen) then
        return true
    end

    if table.indexof(campScreen, target.camp.value) ~= -1 then
        return true
    end
    return false
end

---@param target EcsEntity
function SkillBehavior:filterByBuffLabel(caster, target)
    if not isValidValue(self.behaviorTemplateVO.BuffLabelScreen) then
        return true
    end

    if not target.buff then
        return false
    end

    local allLabelDict = table.create()
    target.buff:getAllBuffLabel(allLabelDict)
    local nType = self.behaviorTemplateVO.BuffLabelScreenType
    local result = false
    if nType == 1 then
        --- All
        result = self:_allBuffLabel(allLabelDict)
    elseif nType == 2 then
        --- Any
        result = self:_anyBuffLabel(allLabelDict)
    elseif nType == 3 then
        --- not All
        result = not self:_allBuffLabel(allLabelDict)
    elseif nType == 4 then
        --- not Any
        result = not self:_anyBuffLabel(allLabelDict)
    else
        result = true
    end
    table.release(allLabelDict)
    return result
end

function SkillBehavior:_allBuffLabel(allLabelDict)
    local buffLabelScreen = self.behaviorTemplateVO.BuffLabelScreen
    for _, label in ipairs(buffLabelScreen) do
        if not allLabelDict[label] then
            return false
        end
    end
    return true
end

function SkillBehavior:_anyBuffLabel(allLabelDict)
    local buffLabelScreen = self.behaviorTemplateVO.BuffLabelScreen
    for _, label in ipairs(buffLabelScreen) do
        if allLabelDict[label] then
            return true
        end
    end
    return false
end

function SkillBehavior:filterByTargetType(caster, target)
    if self.behaviorTemplateVO.TargetType[1] == "All" then
        return true
    end
    if isValidValue(self.behaviorTemplateVO.TargetType) and target.category then
        if table.indexof(self.behaviorTemplateVO.TargetType, target.category.value) > 0 then
            return true
        end
    end
    return false
end

---@param arr EcsEntity[]
function SkillBehavior:getLimitEntities(arr, entity)

    local hitParams = self.behaviorTemplateVO.HitParameter
    if hitParams[1] ~= 1 then
        --- 去重
        local dict = table.create()
        local tempArr = table.merge(table.create(), arr)
        local testId
        for _, e in ipairs(tempArr) do
            if e.partNpc then
                local owner = self.world:getEntity(e.owner.entityId)
                if owner and not owner.banish and
                        self:filterByCamp(owner, entity) and
                        self:filterByBuffLabel(owner, entity) and
                        self:filterByTargetType(owner, entity) then
                    testId = e.owner.entityId
                else
                    testId = e.id
                end
            else
                testId = e.id
            end

            if not dict[testId] then
                dict[testId] = true
            else
                table.removebyvalue(arr, e)
            end
        end
        table.release(dict)
        table.release(tempArr)
    end

    local limitNumber = self.behaviorTemplateVO.MaxObject
    if limitNumber == -1 then
        return arr
    else
        for i = limitNumber + 1, #arr do
            arr[i] = nil
        end
    end
    return arr
end

---@param limitEntities EcsEntity[]
---@param entity EcsEntity
function SkillBehavior:sortEntities(limitEntities, entity)
    local priority = self.behaviorTemplateVO.BuffPriority
    if priority == 3 then
        self.world:shuffle(limitEntities)
    else
        local dict = table.create()
        for _, v in ipairs(limitEntities) do
            dict[v] = LuaClass.FP.pop()
            LuaClass.TSVector2.DistanceSquared(v.transform.position, entity.transform.position, dict[v])
        end

        if priority == 1 then
            table.sort(limitEntities, function(a, b)
                return dict[a] < dict[b]
            end)
        else
            table.sort(limitEntities, function(a, b)
                return dict[a] > dict[b]
            end)
        end

        for k, v in pairs(dict) do
            LuaClass.FP.push(v)
            dict[k] = nil
        end
        table.release(dict)
    end
    return limitEntities
end

---@param entity EcsEntity
function SkillBehavior:finish(entity)
    -- if self._motionType then
    --     entity.motion.motionType = self._motionType
    --     printJax("SkillBehavior:finish ", entity.motion.motionType)
    -- end
    if self.behaviorTemplateVO.NextBehavior == -1 then
        local skilling = false
        if entity.skill then
            local skills = entity.skill.value
            for _, value in ipairs(skills) do
                if value ~= self._skill and value.animStateSkilling then
                    skilling = true
                    break
                end
            end
        end

        if self._skill.animStateSkilling and not skilling then
            self.world:notifyEvent(LuaClass.EntityEvent.SetAnimatorState, entity, "skilling", false)
        end
    end
    self._isPlaying = false
    self._isEffecting = false
    self.isFinish = true
end

return SkillBehavior
```

## Buff的添加

所有的buff添加接口封装在Entity身上

```lua
---@param buffId integer
---@param caster EcsEntity
---@param isTransmitBuff boolean 是否是传递buff，传递buff不会继续传递
function EcsEntity:addBuff(buffId, caster, isTransmitBuff)
    --if buffId == 990903421 then
    --    local a = 1
    --end
    if not self.buff then
        error("not BuffComponent id = " .. self.id)
    end
    local buffTempVO = LuaClass.BuffDatatable:getByID(buffId)

    if self:canAddBuff(buffId) then
        local buff = self.buff:getBuffById(buffId)
        local hasBuff = buff ~= nil
        if not hasBuff then
            buff = LuaClass.Buff(buffId, caster.id, self.id, self._owner)
            self.triggerEventIndex:addQuickIndex(buff, buff.countReduceCondition)
            self.triggerEventIndex:addQuickIndex(buff, buff.durationReduceCondition)
        end

        self:addTriggerEvent(LuaClass.FightEnum.TriggerType.AddBuff, self, caster, buff.buffId, buff:getBuffLabel())
        if self.partNpc then
            local owner = self._owner:getEntity(self.owner.entityId)
            if owner then
                owner:addTriggerEvent(LuaClass.FightEnum.TriggerType.AddBuff, self, caster, buff.buffId, buff:getBuffLabel())
            end
        end
        caster:addTriggerEvent(LuaClass.FightEnum.TriggerType.GiveBuff, caster, self, buff.buffId, buff:getBuffLabel())
        if caster.partNpc then
            local casterOwner = self._owner:getEntity(caster.owner.entityId)
            if casterOwner then
                casterOwner:addTriggerEvent(LuaClass.FightEnum.TriggerType.GiveBuff, caster, self, buff.buffId, buff:getBuffLabel())
            end
        end

        if not hasBuff then
            printSkillLog("EcsEntity addBuff: ", buffId, caster.category.value, caster.id)
            self.buff:addBuff(buff)
            buff:onAdd(caster, self)
            printSkillLog("EcsEntity allBuff: ", self.buff:getAllBuffIds())
        else
            printSkillLog("EcsEntity accumulate buff: ", buffId, caster.category.value, caster.id, buff.count)
            buff:accumulate()
            buff:execute(caster, self)
        end

        if buff.isFinish then
            self:removeBuff(buff, caster)
        end
    end

    --- buff 传递
    if not isTransmitBuff and (self.partNpc or self.partNpcList) then
        ---@type EcsEntity
        local owner
        if buffTempVO.Transmit == 1 then
            if self.owner then
                owner = self._owner:getEntity(self.owner.entityId)
                if owner and not owner:isDisposed() then
                    -- todo存在问题吧
                    owner:addBuff(buffId, caster, true)
                end
            end
        elseif buffTempVO.Transmit == 2 then
            if self.owner then
                owner = self._owner:getEntity(self.owner.entityId)
            else
                owner = self
            end

            if owner then
                if owner ~= self and not owner:isDisposed() then
                    owner:addBuff(buffId, caster, true)
                end

                for _, id in ipairs(owner.partNpcList.value) do
                    local part = self._owner:getEntity(id)
                    if part and part ~= self and not part:isDisposed() then
                        part:addBuff(buffId, caster, true)
                    end
                end
            end
        end
    end
end

---@param buff Buff
function EcsEntity:canAddBuff(buffId)
    if self.property then
        local buffTempVO = LuaClass.BuffDatatable:getByID(buffId)
        local buffId = self.property.buffIdImmune[buffId]
        if buffId then
            return false
        end

        if isValidValue(buffTempVO.BuffLabel) then
            for _, label in ipairs(buffTempVO.BuffLabel) do
                if self.property.buffLabelImmune[label] then
                    return false
                end
            end
        end
    end
    return true
end

---@param buff Buff
---@param caster EcsEntity
function EcsEntity:removeBuff(buff, caster, endType)
    if type(buff) == "number" then
        buff = self.buff:getBuffById(buff)
    end
    if not buff then
        return
    end
    printSkillLog("EcsEntity removeBuff: ", buff._buffTempVO.ID, self.category.value, self.id)
    endType = endType or LuaClass.FightEnum.BuffEndType.LengthEnd
    buff:remove(caster, self)

    self.triggerEventIndex:removeQuickIndex(buff, buff.countReduceCondition)
    self.triggerEventIndex:removeQuickIndex(buff, buff.durationReduceCondition)
    self.buff:removeBuff(buff)

    printSkillLog("EcsEntity allBuff: ", self.buff:getAllBuffIds())
    self:addTriggerEvent(LuaClass.FightEnum.TriggerType.BuffRemoved, buff.buffId, buff._buffTempVO.BuffLabel, endType)
end

---@param buffs Buff[]
---@param caster EcsEntity
function EcsEntity:removeBuffs(buffs, caster, endType)
    for _, buff in ipairs(buffs) do
        self:removeBuff(buff, caster, endType)
    end
end
```

