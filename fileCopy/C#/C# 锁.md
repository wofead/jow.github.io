# C# 锁

事务T在度某个数据对象（如表、记录等）操作之前，先向系统发出请求，对其加锁，加锁后事务T就对数据库对象有一定的控制，在事务T释放它的锁之前，其他事务不能更新此数据对象。

## 锁的类别

### 排它锁（又称写锁，X锁）

**一句总结：会阻塞其他事务读和写。**

若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。

#### 共享锁：（又称读取，S锁）

**一句总结：会阻塞其他事务修改表数据。**

若事务T对数据对象A加上S锁，则其他事务只能再对A加S锁，而不能X锁，直到T释放A上的锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

## 锁的数据颗粒

锁和S锁都是加载某一个数据对象上的。也就是数据的粒度。

按封锁的数据粒度分类如下：

### 行级锁定（row-level）：

**一句总结：行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。**

详细：行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。
缺陷：由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。

### 表级锁定（table-level）：

**一句总结：表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。**

详细：和行级锁定相反，表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。

### 页级锁定（page-level）：（MySQL特有）

**一句总结：页级锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。**

详细：页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。
缺陷：页级锁定和行级锁定一样，会发生死锁。

## C# 中的锁

### 1.互斥锁lock（基于Monitor实现）

定义：

```c#
private static readonly object Lock = new object();
```

使用：

```c#
lock (Lock)
{
　　//todo
}
```

作用：**将会锁住代码块的内容，并阻止其他线程进入该代码块，直到该代码块运行完成，释放该锁。**

注意：**定义的锁对象应该是 私有的，静态的，只读的，引用类型的对象，这样可以防止外部改变锁对象**

### 2.互斥锁Monitor

定义：

```c#
private static readonly object Lock = new object();
```

使用：

```c#
Monitor.Enter(Lock);
//todo
Monitor.Exit(Lock);
```

作用：**将会锁住代码块的内容，并阻止其他线程进入该代码块，直到该代码块运行完成，释放该锁。**

注意：**定义的锁对象应该是 私有的，静态的，只读的，引用类型的对象，这样可以防止外部改变锁对象Monitor有TryEnter的功能，可以防止出现死锁的问题，lock没有**

### 3.互斥锁Mutex

定义：

```c#
private static readonly Mutex mutex = new Mutex();
```

使用：

```c#
mutex.WaitOne();
//todo
mutex.ReleaseMutex();
```

作用：**将会锁住代码块的内容，并阻止其他线程进入该代码块，直到该代码块运行完成，释放该锁。**

注意：**定义的锁对象应该是 私有的，静态的，只读的，引用类型的对象，这样可以防止外部改变锁对象Mutex本身是可以系统级别的，所以是可以跨越进程的**

## 4.读写锁ReaderWriterLockSlim 

定义：

```c#
private static readonly ReaderWriterLockSlim LockSlim = new ReaderWriterLockSlim();
```

使用：

```c#
//写锁
try
{
LockSlim.EnterWriteLock();

//todo

}
catch (Exception ex)
{
}
finally
{
LockSlim.ExitWriteLock();
}

//读锁
try
{
LockSlim.EnterReadLock();

}
catch (Exception ex)
{
}
finally
{
LockSlim.ExitReadLock();
}
```

规则：**读读不互斥 读写互斥 写写互斥**

作用：**当同一个资源被多个线程读，少个线程写的时候，使用读写锁**

注意：**定义的锁对象应该是 私有的，静态的，只读的，引用类型的对象，这样可以防止外部改变锁对象Mutex本身是可以系统级别的，所以是可以跨越进程的**