# 浮点数和定点数的相互转换

* 浮点：小数点非固定的数，可表示数据范围较广，整数，小数都可表示。包含float，double；
* 定点：小数点固定，可表示整数，小数。int本质是小数点位于末尾的32位定点数而已；

## 浮点数的表示

规定浮点数格式为：
$$
V=(-1)^s*M*2^E
$$

* s表示符号位，当s=0，V为正数；当s=1，V为负数
* M表示尾数，2 &gt; M &gt; = 1 2&gt;M&gt;=12>M>=1
* E表示阶码

将其封装到32位的字中：

| 符号位 | 阶码 | 尾数 |
| ------ | ---- | ---- |
| 1      | 8    | 23   |

根据32位数计算为十进制：
$$
V=(-1)^s*(1.M)*2^{e-127}
$$
可以得出以下结论：

* 浮点数表示比整型那些更为复杂。如int中0…01000表示8，0…01001表示9，而浮点不能这样简单。
* 浮点数不能移位。因为各个位有特殊含义。像int数乘2可以左移1位实现。

### 浮点数浮在哪里

我们说浮点数的小数点不是固定的，是浮动的，那么如何理解？通过例子可直观体验。

| 符号 | 阶码 | 尾数 |
| ---- | ---- | ---- |
| 0    | 0111 | 001  |

这个浮点数表示十进制的1.125

| 符号 | 阶码 | 尾数 |
| ---- | ---- | ---- |
| 0    | 0111 | 010  |

若阶码不变，尾数加1，则表示十进制的1.25

| 符号 | 阶码 | 尾数 |
| ---- | ---- | ---- |
| 0    | 1000 | 001  |

若尾数不变，阶码加1，则表示十进制的2.25

## 定点数的表示法

对于计算机来说，浮点定点的概念是看不见的，因为它只能看到：0…00001110，至于它表示多少，是逻辑层面的设置。你如果让它是int那就按照int表示法对每个位赋予意义，如果你让它是float就按照float表示法赋予意义。

对于00011100 0001110000011100表示的定点数：

* 如果我们设定小数点是位于最后一位的，即00011100. 00011100.00011100.则其表示28
* 若设定小数点位于后三位的，即00011.100 00011.10000011.100则其表示3.50
* 若设定小数点位于后四位的，即0001.1100 0001.11000001.1100则其表示1.75

可以看到：

* 小数位数越多，表示的精度越高。若小数点后有n位，则其表示的最大精度为
  $$
  1/(2^n)
  $$

* 整数位数越多，可表示的最大值越大。

以8位为例，最高位为符号位：

* 若整数位占4位，小数位占3位，则其最大精度为0.125，最大值为15.875
* 若整数位占5位，小数位占2位，则其最大精度为0.250，最大值为31.750
* 若整数位占6位，小数位占1位，则其最大精度为0.500，最大值为63.500
* 若整数位占7位，小数位占0位，则其最大精度为1.000，最大值为127

## 浮点数 & 定点数

我们用8位定点数，1个符号位，4个整数位，3个小数位。这个3称为量化系数。该过程称为量化。

（我们总是将非离散值量化到离散值空间，处理更为简单）
$$
int8 = float32 * 2^3 \\
float32 = int8 / 2^3
$$
可以这样理解：量化系数 n nn 决定了我们逻辑上认为01序列中可表示的单位值$1/2^n$，CPU读取的数字表示有多少份单位值。

举例来说，对于固定的01序列值：0001,1100

| 量化系数 | CPU读取值 | 单位值 | 表示逻辑值 |
| -------- | --------- | ------ | ---------- |
| 3        | 28        | 0.125  | 3.5        |
| 2        | 28        | 0.250  | 7.0        |

同样的int8数，因为量化系数的不同，代表着不同的f32值。

## 总结

* 浮点数和定点数的转换是一种映射。将较为密集的数据空间（F32）映射到较为稀疏的空间（int8）；
* 定点数的小数点实际中是没有的，这只是我们逻辑上的一种设定。01序列是一样的，CPU读取都是相同的，因为我们逻辑上小数点的不同位置，我们认为它代表的值是不同的；