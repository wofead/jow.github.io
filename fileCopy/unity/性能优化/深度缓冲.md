# 深度缓冲

深度缓冲区与帧缓冲区相对应，用于记录上面每个像素的深度值，通过深度缓冲区，我们可以进行深度测试，从而确定像素的遮挡关系，保证渲染正确。

## 何为深度

深度其实就是该象素点在3d世界中距离摄象机的距离（绘制坐标），深度缓存中存储着每个象素点（绘制在屏幕上的）的深度值！深度值（Z值）越大，则离摄像机越远。

## 为什么需要深度？

在不使用深度测试的时候，如果我们先绘制一个距离较近的物体，再绘制距离较远的物体，则距离远的物体因为后绘制，会把距离近的物体覆盖掉，这样的效果并不是我们所希望的。而有了深度缓冲以后，绘制物体的顺序就不那么重要了，都能按照远近（Z值）正常显示，这很关键。

## 深度缓冲原理

深度缓冲区原理就是把一个距离观察平面(近裁剪面)的深度值(或距离)与窗口中的每个像素相关联。

首先，使用glClear(GL_DEPTH_BUFFER_BIT),把所有像素的深度值设置为最大值(一般是远裁剪面)。然后，在场景中以任意次序绘制所有物体。硬件或者软件所执行的图形计算把每一个绘制表面转换为窗口上一些像素的集合，此时并不考虑是否被其他物体遮挡。其次，OpenGL会计算这些表面和观察平面的距离。如果启用了深度缓冲区，在绘制每个像素之前，OpenGL会把它的深度值和已经存储在这个像素的深度值进行比较。新像素深度值<原先像素深度值，则新像素值会取代原先的；反之，新像素值被遮挡，他颜色值和深度将被丢弃。为了启动深度缓冲区，必须先启动它，即glEnable(GL_DEPTH_TEST)。每次绘制场景之前，需要先清除深度缓冲区，即glClear(GL_DEPTH_BUFFER_BIT)，然后以任意次序绘制场景中的物体。

## 深度测试

在默认情况是将需要绘制的新像素的z值与深度缓冲区中对应位置的z值进行比较，如果比深度缓存中的值小，那么用新像素的颜色值更新帧缓存中对应像素的颜色值。
但是可以使用glDepthFunc(func)来对这种默认测试方式进行修改。其中参数func的值可以为GL_NEVER（没有处理）、GL_ALWAYS（处理所有）、GL_LESS（小于）、GL_LEQUAL（小于等于）、GL_EQUAL（等于）、GL_GEQUAL（大于等于）、GL_GREATER（大于）或GL_NOTEQUAL（不等于），其中默认值是GL_LESS。
一般来将，使用glDepthFunc(GL_LEQUAL);来表达一般物体之间的遮挡关系。

## 所带来的弊端

启用了深度测试，那么这就不适用于同时绘制不透明物体。当需要绘制半透明物体时，需注意，在绘制半透明物体时前，还需要利用glDepthMask(GL_FALSE)将深度缓冲区设置为只读形式，否则可能出现画面错误。为什么呢，因为画透明物体时，将使用混色，这时就不能继续使用深度模式，而是利用混色函数来进行混合。这一来，就可以使用混合函数绘制半透明物体了。

## 深入

像素的深度值是由视矩阵和投影矩阵决定的。在近裁平面上的像素深度值为0，在远裁平面上的像素的深度值为1。场景中的每个对象都需进行绘制，通常最靠近相机的像素会被保留，这些对象阻挡了在它们后面的对象的可见性。

深度缓冲通常还包含stencil bits – 所以深度缓冲又被叫做depth-stencil缓冲。深度缓冲总是32 bits，但可以用不同的方式组合，类似于纹理格式。常用的深度格式是Depth32，这种格式中32 bits都用来存储深度信息。另一个常用格式是DepthFormat.Depth24Stencil8，这种格式中24 bits用于深度计算而8 bits用于模版缓冲（stencil buffer）。

## 补充内容

颜色缓冲区（COLOR_BUFFER）就是帧缓冲区（FRAME_BUFFER）,你需要渲染的场景最终每一个像素都要写入该缓冲区,然后由它在渲染到屏幕上显示.

