# 字节顺序

字节序指的是多字节的数据各字节的存储顺序。在几乎所有计算机中，多字节数据被存储为连续的字节序列。例如，一个4字节的int类型变量a，其存储的起始地址为`0x804900`，那么a的四个字节将被分别存在`0x804900`，`0x804901`，`0x804902`，`0x804903`的位置。但是问题来了，a的最低有效位可以存储在最前面，也可以存储在高最后面，就有两种不同的存储顺序。这就引出了大端序和小端序。

## 大端序和小端序

实际上，如果**最低有效位在最高有效位的前面**，则该存储规则为**小端序**；反之，如果**最低有效位在最高有效的后面**，则该存储规则为**大端序**。不同的处理器体系，采用的字节序可能是不同的。例如，`x86`采用小端序，而`PowerPc 970`等采用大端序。那么如此一来，不同机器之间的数据传输是不是会出问题呢？

## 本地序和网络序

本地序（也称主机序）即指前面处理器本身所采用的字节序，因此有的大端序，有的小端序。而网络序，是指网络传输采用的字节序。所幸，网络序是标准化的，即一般统一采用大端序。因此，**发送网络数据之前需要将数据转换为网络序**，从而避免了前面所担心的问题。而C语言也针对整型数据提供了一组接口，`htonl`、`htons`用于本地序转网络序，以及`ntohl`、`ntohs`用于网络序转本地序。

## 示例

我们通过一个例子来观察大端序和小端序，本地序和网络序的不同。示例程序做的事情很简单，定义整型变量a，将a的每一个字节的地址和值打印出来，将其转换为网络序之后，再打印观察。程序清单如下：

```c
//endiac.c
#include<stdio.h>
#include<arpa/inet.h>
void stringToHex(char *string, unsigned int len)
{
    unsigned int loop = 0;
    char *temp = string;
    if(NULL == temp){
        printf("input para is NULL\n");
        return;
    }
    if(loop = 0; loop<len, loop ++){
        printf("%p:0x%2x\n",temp,*(temp));
        temp++;
    }
}
int mian(int argc, char *argv[]){
    //x86为小端
    int a = 0x12345678;
    printf("转换之前\n");
    stringToHex((char*)&a,sizeof(int));
    /*转为网络字节序之后再打印*/
    printf("转换之后\n");
    a = htonl(a);/*转换为网络序*/
    printf("a = %d\n",a);
    stringToHex((char*)&a,sizeof(int));
    return 0 ;
    
}



```

```tex
//output
转换之前
a = 305419896
0x7ffc2018d844:0x78
0x7ffc2018d845:0x56
0x7ffc2018d846:0x34
0x7ffc2018d847:0x12
转换之后
a = 2018915346
0x7ffc2018d844:0x12
0x7ffc2018d845:0x34
0x7ffc2018d846:0x56
0x7ffc2018d847:0x78
```

## 为什么不统一字节序

既然每次都发送网络数据之前都要转换，为什么不统一字节序呢？实际上，大小端各有优劣：

- 计算都是从低位开始的，因此计算机内部处理采用小端序，效率较高。
- 而大端序存储的时候，由于符号位在高位，因此对于数据征服或大小的判断也就方便许多。另外，大端序也更符合人类的阅读习惯。

再由于各个芯片厂商的坚持，字节序的问题也就一直没有统一。大小端争端起源于吃鸡蛋时先打破大端还是小端，有兴趣的读者可以搜索一下。

## 总结

在网络应用中，字节序的问题不可忽略，否则可能出现无法预知的问题（如果两台机器本地序相同，且都不做字节序转换，那么侥幸不会出现什么问题）。通过前面的介绍和分析，我们总结出以下几点：

- 不同处理器之间采用的字节序可能不同。
- 有些处理器的字节序是确定的，有些处理器的字节序是可配置的。
- 网络序一般统一为大端序。
- 数据从本地传输到网络，需要转换为网络序，接收到的网络数据需要转换为本地序后使用。
- C提供了一组接口用于整型数据在本地序和网络序之间的转换。
- 多字节数据对象才需要转字节序，例如int，short等，而char不需要。
- 由于处理器是按照IEEE标准处理float和double的（参考：[对浮点数的一些理解](http://mp.weixin.qq.com/s?__biz=MzI2OTA3NTk3Ng==&mid=2649283763&idx=1&sn=7244a95dcba1e3581851384cb3337650&chksm=f2f9afd4c58e26c27ec3ac39b8433d9f02998603a8000931fb6d5882f46c0a4e73cf784d6f74&scene=21#wechat_redirect)），因此也不需要转字节序。
- 由于Java虚拟机的存在，Java不需要考虑大小端的问题。