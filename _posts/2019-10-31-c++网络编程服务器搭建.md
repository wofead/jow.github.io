---
layout:     post
title:      c++网络编程，服务器初步搭建
subtitle:   服务器
date:       2019-10-31
author:     Jow
header-img: img/about-bg-walle.jpg
catalog: 	 true 
tags:
    - c++
    - network

---

### 目录
1. socket函数
2. connect函数
3. bind函数

> 认真学习，增强自己的能力和知识面。


## socket函数

在网络编程中，socket函数十分常见，函数的返回值对应了一个类似于文件句柄的数值，通过该数值可以进行后续的一系列 connect，bind函数的调用。

实质上就是在系统中为了收发数据开辟的一块缓冲区，这块缓冲区在系统的内核中是以数组的方式实现的，每个数组中存放着一个指向缓冲区的指针。而返回的数值是指针作为元素在数组中的位序。

```c++
int socket(int domin, int type, int protocol);
```

 **返回值**：文件描述符

**domin**:用于指定创建嵌套字的时候所使用的协议簇。可选择值：

* AF_UNIX: 本机内进行通信的套接字
* AF_INET: 用于 IPv4 TCP/IP  协议
* AF_INET: 用于 IPv6 TCP/IP 协议

**type**：用于指定嵌套字类型。可选值：

* SOCK_STREAM:创建TCP流套接字
* SOCK_DGRAM:创建UDP数据报套接字
* SOCK_RAM：常见原始套接字

**protocol**:通常设定为数值0

```c++
#include<WinSock2.h>
#include<iostream>


#pragma comment(lib,"ws2_32.lib")  

using namespace std;

//创建socket

int createSocket();

int main()
{
	//初始化WSA  
	WORD sockVersion = MAKEWORD(2, 2);
	WSADATA wsaData;
	if (WSAStartup(sockVersion, &wsaData) != 0)
	{
		cout << "win socket 初始化失败！" << endl;
		return 0;
	}

	for (int i = 0; i < 10; i++)
	{
		int sk = createSocket();
		cout << "嵌套字：" << sk << endl;
		closesocket(sk);
	}
	return 0;

}

int createSocket()
{

	//创建嵌套字
	SOCKET sk = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sk == INVALID_SOCKET)
	{
		cout << "create socket error !" << endl;
		return 0;
	}
	return sk;
}
```

如果不关闭socket的时候将会返回不同的socket。

## connect函数

connect函数是用来与指定地址的一段进行通讯连接的，这个连接可以分为TCP的稳定连接，它是面向字节流的，有着稳妥的确认-收发等一系列安全措施。如果对数据正确性要求高使用它即可。

UDP这样的面向数据报的连接方式，它其实是无连接的，网络传输实时性好，如果对响应的时间要求较高的话，建议使用UDP。

connect函数多半用于客户端向服务器发送请求，通过connect的参数来指出发送请求的目的服务器。

在这里要知道一下几个常用函数的数据结构。

**struct sockaddr_in**:在网络编程中常用来存放通信端的IP地址端口号等信息的结构体。

```c++
struct sockaddr_in
{
	unsigned short sin_family;//地址类型AF_INET（首选，常用），AF_INET6
	unsigned short sin_pot;//端口号，配合htons将主机小端模式转化为大端模式  //htons:host to net (short)
	struct in_addr;//ip地址
	unsigned chat sin_zero[8];//填充字节。
}
```

在这里，操作系统常为小端模式；通讯协议为大端模式。

小端模式是高位存在高位，低位存低位。

大端模式高位存低位，低位存高位。

这里我们再聊一下sockaddr，在使用方面通常socketaddr_in来进行复制操作，然后通过强制转化的方式将其转换为sockaddr来作为函数的参数来使用。

connect函数：

```c++
int connect(int sockfd, const struct sockaddr * serv_addr, socket_len addrlen);

```

1. scokfd:通过调用socket函数正确执行后的返回值。
2. serv_addr:运行connect函数的客户端发送请求的服务端网络地址变量
3. addrlen：第二个参数服务器网络地址变量的长度。

在使用参数2的时候，一般创建struct sockaddr_in serv_addr变量，根据实际的应用为其赋值，然后对其取地址强制转换成struct sockaddr指针结构。(strcut sockaddr *)(&serv_addr)。

**inet_aton(const char * string, struct in_addr *addr)**:这个方法的作用，将ascii码表示的IP地址转换为一个32位的网络地址（使用struct inn_addr表示）。如果转换正确返回值为0，失败返回非零负数。

```c++
#include<WinSock2.h>
#include<iostream>

#define PORT 9003


#pragma comment(lib,"ws2_32.lib")  
#pragma warning(disable:4996)

using namespace std;

//创建socket

int createSocket();
int connectServer(SOCKET sk);

void getIP(char* szHostaddress);

int main()
{
	//初始化WSA  
	WORD sockVersion = MAKEWORD(2, 2);
	WSADATA wsaData;
	if (WSAStartup(sockVersion, &wsaData) != 0)
	{
		cout << "win socket 初始化失败！" << endl;
		return 0;
	}

	SOCKET sk = createSocket();
	connectServer(sk);
	return 0;

}

void getIP(char* szHostAddress)
{
	char szHostname[100] = "localhost";
	//得到来自服务器的名字
	if (gethostname(szHostname, sizeof(szHostname) != SOCKET_ERROR))
	{
		//解析主机名获取主机地址
		HOSTENT* pHostEnt = gethostbyname(szHostname);
		if (pHostEnt != NULL)
		{
			sprintf(szHostAddress, "%d.%d.%d.%d",
				(pHostEnt->h_addr_list[0][0] & 0x00ff),
				(pHostEnt->h_addr_list[0][1] & 0x00ff),
				(pHostEnt->h_addr_list[0][2] & 0x00ff),
				(pHostEnt->h_addr_list[0][3] & 0x00ff)
				);
			cout << szHostAddress << endl;
			char adress[200];
			//IP地址，这种方法或许更好
			for (int i = 0; pHostEnt->h_addr_list[i]; i++) {
				strcpy(adress, inet_ntoa(*(struct in_addr*)pHostEnt->h_addr_list[i]));
				//adress = inet_ntoa(*(struct in_addr*)pHostEnt->h_addr_list[i]);
				cout << adress << endl;
				printf("IP addr %d: %s\n", i + 1, inet_ntoa(*(struct in_addr*)pHostEnt->h_addr_list[i]));
			}
		}
	}
}

int createSocket()
{
	//创建嵌套字
	SOCKET sk = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sk == INVALID_SOCKET)
	{
		cout << "create socket error !" << endl;
		closesocket(sk);
		WSACleanup();
		return FALSE;
	}
	return sk;
}

int connectServer(SOCKET sockfd)
{
	//赋值通信地址
	char HostAddress[200];
	//获取IP地址信息
	getIP(HostAddress);
	SOCKADDR_IN serv_addr;

	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(PORT);
	serv_addr.sin_addr.s_addr = inet_addr(HostAddress);

	if (SOCKET_ERROR == connect(sockfd, (const sockaddr*)& serv_addr, sizeof(serv_addr)))
	{
		cout << "failed to connect server!" << endl;
		closesocket(sockfd);
		WSACleanup();
		return FALSE;
	}
	return 0;
}
```

在这里我们使用几个函数，现在我们来分别的介绍一下这些函数的作用，首先gethostbyname，这个函数的作用是让我们可以根据hostname来获取ip地址，我们可以通过它来获取本地的ip地址，或者其他网址的IP地址。

下面我们通过一个例子获取百度的ip地址：

```c++
#include <stdio.h>
#include <stdlib.h>
#include <WinSock2.h>
#pragma comment(lib, "ws2_32.lib")
int main(){
    WSADATA wsaData;
    WSAStartup( MAKEWORD(2, 2), &wsaData);
    struct hostent *host = gethostbyname("www.baidu.com");
    if(!host){
        puts("Get IP address error!");
        system("pause");
        exit(0);
    }
    //别名
    for(int i=0; host->h_aliases[i]; i++){
        printf("Aliases %d: %s\n", i+1, host->h_aliases[i]);
    }
    //地址类型
    printf("Address type: %s\n", (host->h_addrtype==AF_INET) ? "AF_INET": "AF_INET6");
    //IP地址
    for(int i=0; host->h_addr_list[i]; i++){
        printf("IP addr %d: %s\n", i+1, inet_ntoa( *(struct in_addr*)host->h_addr_list[i] ) );
    }
    system("pause");
    return 0;
}
/**
运行结果:
Aliases 1: www.baidu.com
Address type: AF_INET
IP addr 1: 61.135.169.121
IP addr 2: 61.135.169.125
**/
```

在这里我们看到了inet_ntoa函数，它的作用是将网络地址转换成“.”点隔的字符串格。

当我们需要将“.”点隔的字符串转换成无符号长整型可以使用inet_addr("132.241.5.10")。

## bind函数

在网络通信程序中，通过ip:port来确定网络中的唯一一台主机上面的运行的进程，对于客户端而言，通过向指定主机上面端口来发送信息请求对应的服务。服务器在网络编程中指代运行服务器程序的进程，这个是从狭义上来说的，从广义上来说也可以是运行服务器进行的主机。

前者是通过端口号来指定，而后者是通过IP地址来确定。

那么，socket套接字与运行服务器进程的端口号之间有什么联系呢？

这个问题的答案便是bind存在的意义。

服务器程序运行主要是为了接受来自各个端点的客户端的请求，然后根据这个请求给予不同的回复，对于服务器来说，接收信息也好，回复结果也罢，都需要指定的缓冲区来存放这些信息和数据。这个缓冲区则是socket函数的返回值所指定的系统分配的空间的数组下标。

而：IP：PORT则是标定程序运行的主机与进程号码。

那么通过函数bind将运行服务器程序的主机：进程号与缓冲区进行绑定的含义便是将通过socket函数向系统申请的系统空间与运行在当前系统上面的程序进行绑定。也就是为进程分配用来存放网络通信所需要的缓冲空间。

将socket返回的数值理解为空间可以这样来向：socket返回的数值与系统中的文件描述符fd是等价的，fd指向的是系统为文件在系统中开辟的空间，所以通过socket返回的socket_fd也对应着系统为其开辟的一块缓冲区。只不过，文件描述符的fd可以通过某种方式写入到文件中，在用户确认写入之后，将会把缓冲区中的数据写入到系统的磁盘中作为永久保存。而socket对象的sock_fd仅仅是一块缓冲区，当服务器与客户端之间的通信结束之后，该缓冲区通过closesocket(socket_fd);方法调用之后将会被系统回收，没有写到磁盘的机会。

下面来看一下bind函数的描述：

```c++
int bind(int sockfd, struct sockaddr* myaddr, socklen_t addrlen);

// 返回值：成功为0，否则非0负数
```

**sockfd**:该参数便是socket函数的返回值。

**myaddr**:套接字描述字，要绑定的目标主机上的进程描述变量。

**addrlen**: 参数2的长度

在C/S通信模型中

client端使用函数顺序通常是：socket->connect->send/recv

server端使用函数顺序通常是：socket->bind->listen->send/recv


```c++
int getBindDone(SOCKET sk)
{
	SOCKADDR_IN server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_port = PORT;
	server_addr.sin_addr.s_addr = INADDR_ANY;
	if (SOCKET_ERROR == bind(sk,(const sockaddr*) &server_addr, sizeof(server_addr)))
	{
		closesocket(sk);
		WSACleanup();
		return FALSE;
	}
}
```

## 字符串标准库

```lua
string.rep("abc",3)
string.reverse("abc")
string.lower("Abc")
string.upper("abc")

string.sub("abc",1,2) --包含1和2
string.char(97) -- a,转换字符及其内部数值表示形式
string.byte(a) -- 97

string.find("hello world", "wor") --7 9
string.gsub("hello world", "l", ".") --he..o wor.d

```

一般情况下，string内部的函数都是针对于字节进行操作的，当遇到中文就不行了，在这里lua增加了utf8的函数封装。

```lua
local s = "中华人民共和国"
utf8.len(s) --7,返回指定字符串中UTF-8字符的个数
--utf8把字符位置转换成字节位置
print(utf8.codepoint(s,utf8.offset(s,1),utf8.offset(s,2))) -- 
print(utf8.char(20013,21326))
print(utf8.offset(s,3))
print(string.sub(s,1,utf8.offset(s,3) - 1 )) --在使用的时候需要注意，offset返回的是字符的第一个字节位置，在截取的使用时候需要减去1
print(3.5 % 2)
```

## lua中安全访问

通过  (class or {}).  的方式来实现安全访问

## 表的拷贝

表的拷贝除了使用遍历赋值之外，还可以通过table.move函数来实现。

```lua
table.move(a,1,#a,1,{})

local inta = {1,2,3}
local a = {}
local b = {}
for i = 1, 3 do
    table.insert(a,inta)
end

table.move(a,1,#a,1,b)
```

## 可变长参数

在函数中，一个函数为了可以接受可变长的参数列表，一般采用三个点。

用这个三个点获取来的参数列表其实是一个表达式，和return回来多个值是一样的，可以选择接受一个或者多个，也可以通过表的形式全部接受。

但是如果可变长参数中包含无效的nill，那么{...}获得的表可能不再是一个有效的序列。这样会导致一个问题，就是table中存在nil的时候，元素就会被自动移除。假设参数为 1，nil，2，那个打包到table中就只剩下1，2了，table的长度为2，不是一个数组，因为table[2]没有这个键值。

![](https://i.imgur.com/ERw2JLC.png)

这个时候我们可以使用table.pack来打包可变长参数。通过pack打包出来的表会存在一个键值n，表示原来 ... 返回来的参数个数。

通过table.unpack可以解开表，返回内容类似于return表达式。

## 输入和输出

```lua
local file = io.open("a.txt","r")

```