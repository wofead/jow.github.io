---
layout:     post
title:      c++网络编程，服务器初步搭建
subtitle:   服务器
date:       2019-10-31
author:     Jow
header-img: img/about-bg-walle.jpg
catalog: 	 true 
tags:
    - c++
    - network

---

### 目录
1. socket函数
2. 取整
3. 长字符串
4. 字符串标准库
5. lua中安全访问
6. 表的拷贝
7. 可变长参数
8. 输入和输出


> 认真学习，增强自己的能力和知识面。


## socket函数

在网络编程中，socket函数十分常见，函数的返回值对应了一个类似于文件句柄的数值，通过该数值可以进行后续的一系列 connect，bind函数的调用。

实质上就是在系统中为了收发数据开辟的一块缓冲区，这块缓冲区在系统的内核中是以数组的方式实现的，每个数组中存放着一个指向缓冲区的指针。而返回的数值是指针作为元素在数组中的位序。

```c++
int socket(int domin, int type, int protocol);
```

 **返回值**：文件描述符

**domin**:用于指定创建嵌套字的时候所使用的协议簇。可选择值：

* AF_UNIX: 本机内进行通信的套接字
* AF_INET: 用于 IPv4 TCP/IP  协议
* AF_INET: 用于 IPv6 TCP/IP 协议

**type**

## 取整

为了做到公平性取整，应该做到3.5+0.5为偶数则进位，而2.5+0.5为奇数不进位。

```lua
function round(x)
	local f = math.floot(x)
	if	(x == f) or (x % 2.0 == 0.5) then
		return f
	else
		return math.floor(x + 0.5)
	end
end
```

## 长字符串

```lua
local page = [[
fdsaf

fdasf

]]
```

## 字符串标准库

```lua
string.rep("abc",3)
string.reverse("abc")
string.lower("Abc")
string.upper("abc")

string.sub("abc",1,2) --包含1和2
string.char(97) -- a,转换字符及其内部数值表示形式
string.byte(a) -- 97

string.find("hello world", "wor") --7 9
string.gsub("hello world", "l", ".") --he..o wor.d

```

一般情况下，string内部的函数都是针对于字节进行操作的，当遇到中文就不行了，在这里lua增加了utf8的函数封装。

```lua
local s = "中华人民共和国"
utf8.len(s) --7,返回指定字符串中UTF-8字符的个数
--utf8把字符位置转换成字节位置
print(utf8.codepoint(s,utf8.offset(s,1),utf8.offset(s,2))) -- 
print(utf8.char(20013,21326))
print(utf8.offset(s,3))
print(string.sub(s,1,utf8.offset(s,3) - 1 )) --在使用的时候需要注意，offset返回的是字符的第一个字节位置，在截取的使用时候需要减去1
print(3.5 % 2)
```

## lua中安全访问

通过  (class or {}).  的方式来实现安全访问

## 表的拷贝

表的拷贝除了使用遍历赋值之外，还可以通过table.move函数来实现。

```lua
table.move(a,1,#a,1,{})

local inta = {1,2,3}
local a = {}
local b = {}
for i = 1, 3 do
    table.insert(a,inta)
end

table.move(a,1,#a,1,b)
```

## 可变长参数

在函数中，一个函数为了可以接受可变长的参数列表，一般采用三个点。

用这个三个点获取来的参数列表其实是一个表达式，和return回来多个值是一样的，可以选择接受一个或者多个，也可以通过表的形式全部接受。

但是如果可变长参数中包含无效的nill，那么{...}获得的表可能不再是一个有效的序列。这样会导致一个问题，就是table中存在nil的时候，元素就会被自动移除。假设参数为 1，nil，2，那个打包到table中就只剩下1，2了，table的长度为2，不是一个数组，因为table[2]没有这个键值。

![](https://i.imgur.com/ERw2JLC.png)

这个时候我们可以使用table.pack来打包可变长参数。通过pack打包出来的表会存在一个键值n，表示原来 ... 返回来的参数个数。

通过table.unpack可以解开表，返回内容类似于return表达式。

## 输入和输出

```lua
local file = io.open("a.txt","r")

```