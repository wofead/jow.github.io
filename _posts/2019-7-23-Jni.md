---
layout:     post
title:      Android JNI
subtitle:   NDK与JNI基础
date:       2019-7-23
author:     Jow
header-img: img/lua-home-bg-o.jpg
catalog: 	 true 
tags:
    - Android
    - NDK
    - JNI

---

### 目录
1. 导读
2. NDK
3. JNI
4. JNI原理
5. JNI的引用


> If you feel you are sleepy, please have a rest. Then hard work.

要想搞清楚什么是JNI，我们需要将与之相管的内容全部整理出来：
![](https://i.imgur.com/puooyEc.png)

## 导读
> 在Android开发中，Google提供了两种开发包，SDK和NDK，其中SDK是用来Java开发的，而NDK是用来c/c++开发的，即JNI编程方式，第三方应用可以通过JNI调用自己的c动态库，这就是NDK。

## NDK
NDK（Native Develop Kit):是一套允许你使用原生代码语言，例如（c和c++）实现部分应用的工具集。在开发某些类型应用时，这有助于您重复使用这些语言编写的代码库。一般情况下NDK工具把C/C++编译为.co文件，然后再Java中调用。
1. NDK可以提升应用性能(C/C++)
2. 平台之间移植
3. 使用第三方库
4. 代码保护(不容易被反编译)

### NDK到so
![](https://i.imgur.com/iTApdOR.png)
so库，即将C或者C++实现的功能进行打包，将其打包为共享库，让其他程序进行调用，这可以提高代码的复用性。linux生成的共享库以so结尾，在win下是dll结尾。

目前Android系统支持下面其中CPU结构，每一种对应着各自的应用程序二进制接口ABI（Application Binary Interface）：定义了二进制文件（尤其是共享库文件）如何在相应的系统平台运行，从使用的指令集内存对齐以及可用的系统函数库。
1. ARMv5 - armeabi
2. ARMv7 - armeabi-v7a
3. ARMv7 - arm64-v8a
4. x86 - x86
5. MPS - mips
6. MIPS64 - mips64
7. x86_64 - x86_64

## JNI
JNI（Java Native Interface）,即Java本地接口。JNI是Java调用Native 语言的一种特性。通过JNI可以使得Java与C/C++机型交互。由于JNI是JVM中规范的一部分，因此可以是我们可以复用以前用C/C++写的大量代码。JNI是一种弄在Java虚拟机机制下的执行代码的标准机制。
在使用JNI的时候，注意平台的跨建。如果要实现跨平台，就必须将本地代码在不同的操作系统平台下编译出相应的动态库。
![](https://i.imgur.com/SQJYK4M.png)

JNI的命名规则：
```java
JNIExport jstring JNICALL Java_com_example_hellojni_MainActivity_stringFromJNI( JNIEnv* env,jobject thiz ) 
```
jstring 是返回值类型
Java_com_example_hellojni 是包名
MainActivity 是类名
stringFromJNI 是方法名

其中JNIExport和JNICALL是不固定保留的关键字不要修改

如何实现JNI：
1. 在Java中先声明一个native方法
2. 编译Java源文件javac得到.class文件
3. 通过javah -jni命令导出JNI的.h头文件
4. 使用Java需要交互的本地代码，实现在Java中声明的Native方法(如果Java需要与C++交互，那么就用C++实现Java的Native方法)
5. 将本地代码编译成动态库
6. 通过Java命令执行Java程序，最终实现Java调用本地代码。

```java
jdouble Java_pkg_Cls_f__ILjava_lang_String_2 (JNIEnv *env, jobject obj, jint i, jstring s)
{
     const char *str = (*env)->GetStringUTFChars(env, s, 0); 
     (*env)->ReleaseStringUTFChars(env, s, str); 
     return 10;
}
```
* *env：一个接口指针
* obj：在本地方法中声明的对象引用
* i和s：用于传递的参数

JNI有自己的原始数据类型和数据引用类型如下：
![](https://i.imgur.com/OManwWT.png)

## JNI原理
> 在计算机系统中，每一种编程语言豆浆有一个执行环境，执行环境来解释执行执行语言中的语句。

Java语言的执行环境是Java虚拟机（JVM），JVM其实是主机环境中的一个进程，每个JVM都在本地环境中有一个JavaVM结构体，该结构体在创建虚拟机的时候被返回。在JNI环境下创建JVM的函数为JNI_CreateJavaVM。

```java
JNI_CreateJavaVM(JavaVM **pvm, void **penv, void*args);
```
![](https://i.imgur.com/KGoZ9a1.png)
其中JavaVM是JVM在JNI层的代表，JNI全局仅仅有一个JavaVM结构，在里面封装了一些函数指针(or函数表结构)，JavaVm中封装的这些函数指针主要是对JVM操作接口。另外c和c++中的JavaVM的定义有所不同，在c中JavaVM是JNIInvokeInterface_类指针，而在C++中，进行了一次封装，比c中少一个参数。这也是为什么推荐使用c++来编写JNI函数。

JNIEnv：
JINEnv是当前Java线程的执行环境，一个JVM对应一个JavaVM结构体，二一个JVM中可能创建多个Java线程，每个线程对应一个JNIEnv结构，它们保存在线程本地存储TLS中。因此不同的线程JNIEnv不同，而不能相互共享使用。
JavaEnv结构也是一个函数表，在本地代码通过JNIEnv函数表来操作Java数据或者调用Java方法。也就是说，只要在本地代码中拿到了JNIEnv结构，就可以在本地代码中调用Java代码。


![](https://i.imgur.com/e5UiHQp.png)
* 调用Java 函数：JNIEnv代表了Java执行环境，能够使用JNIEnv调用Java中的代码
* 操作Java代码：Java对象传入JNI层就是jobject对象，需要使用JNIEnv来操作这个Java对象

JNIEnv的创建：
* C 中——JNIInvokeInterface：JNIInvokeInterface是C语言环境中的JavaVM结构体，调用 (AttachCurrentThread)(JavaVM, JNIEnv*, void) 方法，能够获得JNIEnv结构体
* C++中 ——_JavaVM：_JavaVM是C++中JavaVM结构体，调用jint AttachCurrentThread(JNIEnv** p_env, void* thr_args) 方法，能够获取JNIEnv结构体；


JNIEnv的释放：
* C 中释放：调用JavaVM结构体JNIInvokeInterface中的(DetachCurrentThread)(JavaVM)方法，能够释放本线程的JNIEnv
* C++ 中释放：调用JavaVM结构体_JavaVM中的jint DetachCurrentThread(){ return functions->DetachCurrentThread(this); } 方法，就可以释放 本线程的JNIEnv

JNIEnv和线程的关系：
* JNIEnv只在当前线程有效：JNIEnv仅仅在当前线程有效，JNIEnv不能在线程之间进行传递，在同一个线程中，多次调用JNI层方便，传入的JNIEnv是同样的
* 本地方法匹配多个JNIEnv：在Java层定义的本地方法，能够在不同的线程调用，因此能够接受不同的JNIEnv

JINEnv相关常用的函数：
```java
jobject NewObject(JNIEnv *env, jclass clazz,jmethodID methodID, ...)：
jobject NewObjectA(JNIEnv *env, jclass clazz,jmethodID methodID, const jvalue *args)：
jobject NewObjectV(JNIEnv *env, jclass clazz,jmethodID methodID, va_list args)：

jstring NewString(JNIEnv *env, const jchar *unicodeChars,jsize len)：
ArrayType New<PrimitiveType>Array(JNIEnv *env, jsize length);
jobjectArray NewObjectArray(JNIEnv *env, jsize length,jclass elementClass, jobject initialElement);
jobject GetObjectArrayElement(JNIEnv *env,jobjectArray array, jsize index);
jsize GetArrayLength(JNIEnv *env, jarray array);
```
第一个参数jclass class 代表的你要创建哪个类的对象，第二个参数,jmethodID methodID代表你要使用那个构造方法ID来创建这个对象。只要有jclass和jmethodID，我们就可以在本地方法创建这个Java类的对象。

通过Unicode字符的数组来创建一个新的String对象。
env是JNI接口指针；unicodeChars是指向Unicode字符串的指针；len是Unicode字符串的长度。返回值是Java字符串对象，如果无法构造该字符串，则为null。

## JNI的引用
Java内存管理这块是完全透明的，new一个对象或者释放一个对象，都是Java自己进行管理的，但是从Java虚拟机创建的对象传到C/C++代码就会产生引用，根据Java的垃圾回收机制，只要存在引用就不会对对象进行垃圾回收。

在JNI规范中定义了三种引用：局部引用、全局引用和弱全局引用。
1. 局部引用(Local Reference)
局部引用，也成本地引用，通常是在函数中创建并使用。会阻止GC回收所有引用对象。这个是最常见的引用类型，基本上通过JNI返回来的引用都是局部引用，例如使用newobject,就会返回创建出来的是实例的局部引用，局部引用值在改native函数中有效，会在函数返回的时候自动释放，也可以使用DeleteLocalRef函数手动释放该对象。
2. 全局引用(Global Reference)
全局引用可以跨方法、跨线程使用，直到被开发者显式释放。类似局部引用，一个全局引用在被释放前保证引用对象不被GC回收。和局部应用不同的是，没有俺么多函数能够创建全局引用。能创建全部引用的函数只有NewGlobalRef，而释放它需要使用ReleaseGlobalRef函数
3. 弱全局引用(Weak Global Reference)
是JDK 1.2 新增加的功能，与全局引用类似，创建跟删除都需要由编程人员来进行，这种引用与全局引用一样可以在多个本地代码有效，不一样的是，弱引用将不会阻止垃圾回收期回收这个引用所指向的对象，所以在使用时需要多加小心，它所引用的对象可能是不存在的或者已经被回收。
4. 引用比较
给定两个引用，我们可以通过下面的代码来判断是否是相同的引用。如果obj1和obj2指向相同的对象，则返回JNI_TRUE(或者1)，否则返回JNI_FALSE(或者0).
```java
(*env)->IsSameObject(env, obj1, obj2)
```
attention:有一个特殊的引用需要注意：NULL，JNI中的NULL引用指向JVM中的null对象，如果obj是一个全局或者局部引用，使用(*env)->IsSameObject(env, obj, NULL)或者obj == NULL用来判断obj是否指向一个null对象即可。但是需要注意的是，IsSameObject用于弱全局引用与NULL比较时，返回值的意义是不同于局部引用和全局引用的。代码如下：
```java
jobject local_obj_ref = (*env)->NewObject(env, xxx_cls,xxx_mid); 
jobject g_obj_ref = (*env)->NewWeakGlobalRef(env, local_ref);
// ... 业务逻辑处理
jboolean isEqual = (*env)->IsSameObject(env, g_obj_ref, NULL);
```