# 明明白白的懂XLua

[toc]

## 热更新

热更新，就是在不重新去应用商店拉去更新包的情况下，从自己的服务器上拉取资源文件，然后进行差异对比读取，这样可以省很多的事情。

但是并不是你想更新什么就更新设么，首先那些基础的，支持你进行差异对比，拉取文件，需要编译的代码，这些东西都是不能做热更新的，我们称这一部分为基本部分，意思是支持你进行热更新和不能做热更新的部分，还有另一个部分就是业务部分，我们需要时常变动的部分。

用游戏来举例子：用户从网上下载下来的那个安装包叫做**母包**，它是我们游戏的最初版本，一般情况下这个包非常的完整，包含这个版本的基础部分和业务部分，当然，你也可以选择只放基础部分，等玩家进入游戏的时候，在把那些业务部分让玩家download下来。这个母包我们一般称之为大版本，是要放到应用商店中让玩家进行下载安装的。

接下来就是可热更新部分了，这部分可以放到我们的资源服务器上，然后每次玩家在登录的时候检测版本号是否和我们服务器上的一致，如果不一致，就告诉客户端你需要下载新的需要更新的资源。这样就可以一致保证玩家玩到的一致都是最新的版本。一本除了大版本，每次的热更新都是一个小的版本，大版本加上每个小版本就是我们完整的最新的游戏包了。

这些痕迹我们在生活中都可以看到，每次我们下载游戏的时候，发现进去一般都是需要更新的，这说明母包之后存在很多需要更新的小版本，然后我们还可以发现这些小版本都是一个接着一个的，这也说明，小版本也是按照顺序累积起来的。

## XLua的简单实用

在Lua中调用C#代码，在Lua中可以直接调用C#中的代码

```lua
CS.UnityEngine.Debug.Log('Hello world!')
```

这个就是通过表，和栈来实现通讯的。

**XLua中的CS变量的功能**

我们在Lua中，经常会使用一些不是Lua层设置和赋值的全局变量，这些变量，要么是自己通过GLobal获取之后进行调用的，要么是在LuaEnv中的init_lua string进行赋值的。像我们常用的CS，cast， typeof，xlua相关的函数，这里还有一点，就是xlua的有些函数是通过另一种途径设置的，在ObjectTranslator中，OpenLib添加方法。**而xlua这个全局变量是在xlua.c里面设置的**。

在下面的代码中有几个疑问？

1. .fqn

```lua
local metatable = {}
local rawget = rawget
local setmetatable = setmetatable
local import_type = xlua.import_type
local import_generic_type = xlua.import_generic_type
local load_assembly = xlua.load_assembly

function metatable:__index(key) 
    --为什么是 .fqn
    local fqn = rawget(self,'.fqn')
    fqn = ((fqn and fqn .. '.') or '') .. key
	-- 这个函数在ObjectTranslator中绑定，实现在StaticLuaCallBacks中
    local obj = import_type(fqn)

    if obj == nil then
        -- It might be an assembly, so we load it too.
        obj = { ['.fqn'] = fqn }
        setmetatable(obj, metatable)
    elseif obj == true then
        return rawget(self, key)
    end

    -- Cache this lookup
    rawset(self, key, obj)
    return obj
end

function metatable:__newindex()
    error('No such type: ' .. rawget(self,'.fqn'), 2)
end

-- A non-type has been called; e.g. foo = System.Foo()
function metatable:__call(...)
    local n = select('#', ...)
    local fqn = rawget(self,'.fqn')
    if n > 0 then
        local gt = import_generic_type(fqn, ...)
        if gt then
            return rawget(CS, gt)
        end
    end
    error('No such type: ' .. fqn, 2)
end

CS = CS or {}
setmetatable(CS, metatable)

typeof = function(t) return t.UnderlyingSystemType end
cast = xlua.cast
if not setfenv or not getfenv then
    local function getfunction(level)
        local info = debug.getinfo(level + 1, 'f')
        return info and info.func
    end

    function setfenv(fn, env)
        if type(fn) == 'number' then fn = getfunction(fn + 1) end
        local i = 1
        while true do
        local name = debug.getupvalue(fn, i)
        if name == '_ENV' then
            debug.upvaluejoin(fn, i, (function()
            return env
            end), 1)
            break
        elseif not name then
            break
        end

        i = i + 1
        end

        return fn
    end

    function getfenv(fn)
        if type(fn) == 'number' then fn = getfunction(fn + 1) end
        local i = 1
        while true do
        local name, val = debug.getupvalue(fn, i)
        if name == '_ENV' then
            return val
        elseif not name then
            break
        end
        i = i + 1
        end
    end
end

xlua.hotfix = function(cs, field, func)
    if func == nil then func = false end
    local tbl = (type(field) == 'table') and field or {[field] = func}
    for k, v in pairs(tbl) do
        local cflag = ''
        if k == '.ctor' then
            cflag = '_c'
            k = 'ctor'
        end
        local f = type(v) == 'function' and v or nil
        xlua.access(cs, cflag .. '__Hotfix0_'..k, f) -- at least one
        pcall(function()
            for i = 1, 99 do
                xlua.access(cs, cflag .. '__Hotfix'..i..'_'..k, f)
            end
        end)
    end
    xlua.private_accessible(cs)
end
xlua.getmetatable = function(cs)
    return xlua.metatable_operation(cs)
end
xlua.setmetatable = function(cs, mt)
    return xlua.metatable_operation(cs, mt)
end
xlua.setclass = function(parent, name, impl)
    impl.UnderlyingSystemType = parent[name].UnderlyingSystemType
    rawset(parent, name, impl)
end

local base_mt = {
    __index = function(t, k)
        local csobj = t['__csobj']
        local func = csobj['<>xLuaBaseProxy_'..k]
        return function(_, ...)
                return func(csobj, ...)
        end
    end
}
base = function(csobj)
    return setmetatable({__csobj = csobj}, base_mt)
end
```

## Lua中获取C#类对应的Table表

> XLua中有两种方式来实现Lua调用CS中的方法，一种是反射来调用，一种是生成适配的代码。

在获取对应的Lua表时候，使用的是import_type方法，也是在创建LuaEnv实例的时候进行注册的代码：

```c#
ObjectTranslator.cs
public void OpenLib(RealStatePtr L) {
    if (0 != LuaAPI.xlua_getglobal(L, "xlua")){  throw new Exception("call xlua_getglobal fail!" + LuaAPI.lua_tostring(L, -1));} 
    LuaAPI.xlua_pushasciistring(L, "import_type");
    LuaAPI.lua_pushstdcallcfunction(L,importTypeFunction);
    LuaAPI.lua_rawset(L, -3); 
}
```

上面代码中的*importTypeFunction*是一个C#委托当Lua中是调用import_type时候Lua会调用对应的C方法(Lua调用CFunction的原理,请查找Lua手册)，最后会调用到对应的C#委托上来。

```c
XLua.c
LUA_API void luaopen_xlua(lua_State *L) {
   luaL_openlibs(L);
#if LUA_VERSION_NUM == 503
   luaL_newlib(L, xlualib);
   lua_setglobal(L, "xlua");
#else
   luaL_register(L, "xlua", xlualib);
    lua_pop(L, 1);
#endif
}
```

代码很简单，*luaopen_xlua*是一个c函数，属于xlua.dll在创建LuaEnv时候会调用。调用后会设置一个全局变量xlua，也就是ObjectTranslator类中获取的xlua变量。然后将键值对"import_type"=C#委托，压入xlua表中。这样就能在inti_xlua.lua中调用import_type方法了。

## C#中找指定Type对应Lua表的实现

在C#的InportType方法中会尝试在缓存中获取对应的Type。如果Type为空，那说明是第一次尝试引用对应的Type，代码就会判断是使用适配代码还是反射模式，来生辰对应的表。

```c#
StaticLuaCallBacks.cs
ObjectTranslator.cs
//importTypeFunction = new LuaCSFunction(StaticLuaCallbacks.ImportType);
public static int ImportType(RealStatePtr L)
{
    try
    {
        ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);
        //需要查询的类名
        string className = LuaAPI.lua_tostring(L, 1);
        //查找C#对应的Type(此处还没去查找对应Lua的表)
        Type type = translator.FindType(className);
        if (type != null)
        {
            //这句查找Lua中Type对应的表
            if (translator.GetTypeId(L, type) >= 0)
            {
                LuaAPI.lua_pushboolean(L, true);
            }
            else
            {
                return LuaAPI.luaL_error(L, "can not load type " + type);
            }
        }
        else
        {
            LuaAPI.lua_pushnil(L);
        }
        return 1;
    }
}

internal int getTypeId(RealStatePtr L, Type type, out bool is_first, LOGLEVEL log_level = LOGLEVEL.WARN)
{
    int type_id;
    is_first = false;
    //查询是否缓存中有Type对应的Lua表,有就直接返回
    if (!typeIdMap.TryGetValue(type, out type_id)) // no reference
    {
        ...
        is_first = true;
        Type alias_type = null;
        aliasCfg.TryGetValue(type, out alias_type);
        LuaAPI.luaL_getmetatable(L, alias_type == null ? type.FullName : alias_type.FullName);
        if (LuaAPI.lua_isnil(L, -1)) //no meta yet, try to use reflection meta
        {
            LuaAPI.lua_pop(L, 1);
            //此处会去检查是使用反射还是生成适配代码的逻辑
            if (TryDelayWrapLoader(L, alias_type == null ? type : alias_type))
            {
                LuaAPI.luaL_getmetatable(L, alias_type == null ? type.FullName : alias_type.FullName);
            }
            else
            {
                throw new Exception("Fatal: can not load metatable of type:" + type);
            }
        }
        //循环依赖，自身依赖自己的class，比如有个自身类型的静态readonly对象。
        if (typeIdMap.TryGetValue(type, out type_id))
        {
            LuaAPI.lua_pop(L, 1);
        }
        else
        {
            ...
            LuaAPI.lua_pushvalue(L, -1);
            type_id = LuaAPI.luaL_ref(L, LuaIndexes.LUA_REGISTRYINDEX);
            LuaAPI.lua_pushnumber(L, type_id);
            LuaAPI.xlua_rawseti(L, -2, 1);
            LuaAPI.lua_pop(L, 1);
            ...
            //缓存type与其对应到lua中的表
            typeIdMap.Add(type, type_id);
        }
    }
    return type_id;
}
public bool TryDelayWrapLoader(RealStatePtr L, Type type)
{
            if (loaded_types.ContainsKey(type)) return true;
            loaded_types.Add(type, true);
            LuaAPI.luaL_newmetatable(L, type.FullName); //先建一个metatable，因为加载过程可能会需要用到
            LuaAPI.lua_pop(L, 1);
            Action<RealStatePtr> loader;
            int top = LuaAPI.lua_gettop(L);
            //此处如果已经缓存,那么就是生成适配代码注册,
            //这边的逻辑也是为了用的时候才实例化对应的.
            //这个delayWrap是个字典,他的键值对在XLua_Gen_Initer_Register__类实例化时候自动填充
            if (delayWrap.TryGetValue(type, out loader))
            {
                delayWrap.Remove(type);
                //将类方法,字段,成员等加载上来
                loader(L);
            }
            //那么这里就是反射的逻辑了
            else
            {
                 ...
                //用反射将类方法,字段,成员等加载上来
                Utils.ReflectionWrap(L, type, privateAccessibleFlags.Contains(type));
                ...
            }
            ...
            ...
            return true;
}
```

在生成完Type对应的Lua表后还需要设置到Lua上去

下面的代码简单来说就是用前面代码生成的table表设置到CS.UnityEngine[Debug]中：

```lua
//loader(L)和Utils.ReflectionWrap(L, type, privateAccessibleFlags.Contains(type));中都会调用此函数来设置CS.UnityEngine[Debug]
public static void SetCSTable(RealStatePtr L, Type type, int cls_table)
{
   int oldTop = LuaAPI.lua_gettop(L);
   cls_table = abs_idx(oldTop, cls_table);
   LuaAPI.xlua_pushasciistring(L, LuaEnv.CSHARP_NAMESPACE);
   LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);
   List<string> path = getPathOfType(type);
   for (int i = 0; i < path.Count - 1; ++i)
   {
      LuaAPI.xlua_pushasciistring(L, path[i]);
      if (0 != LuaAPI.xlua_pgettable(L, -2))
      {
         LuaAPI.lua_settop(L, oldTop);
         throw new Exception("SetCSTable for [" + type + "] error: " + LuaAPI.lua_tostring(L, -1));
      }
      if (LuaAPI.lua_isnil(L, -1))
      {
         LuaAPI.lua_pop(L, 1);
         LuaAPI.lua_createtable(L, 0, 0);
         LuaAPI.xlua_pushasciistring(L, path[i]);
         LuaAPI.lua_pushvalue(L, -2);
         LuaAPI.lua_rawset(L, -4);
      }
      else if (!LuaAPI.lua_istable(L, -1))
      {
         LuaAPI.lua_settop(L, oldTop);
         throw new Exception("SetCSTable for [" + type + "] error: ancestors is not a table!");
      }
      LuaAPI.lua_remove(L, -2);
   }
   LuaAPI.xlua_pushasciistring(L, path[path.Count - 1]);
   LuaAPI.lua_pushvalue(L, cls_table);
   LuaAPI.lua_rawset(L, -3);
   LuaAPI.lua_pop(L, 1);
   LuaAPI.xlua_pushasciistring(L, LuaEnv.CSHARP_NAMESPACE);
   LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);
   ObjectTranslatorPool.Instance.Find(L).PushAny(L, type);
   LuaAPI.lua_pushvalue(L, cls_table);
   LuaAPI.lua_rawset(L, -3);
   LuaAPI.lua_pop(L, 1);
}
```

### 调用指定c#方法

***使用生成适配代码调用***，所有的生成的代码都在gen目录下：

```c#
UnityEngineDebugWrap.cs
public class UnityEngineDebugWrap
{
     public static void __Register(RealStatePtr L)
     {
          ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);
          System.Type type = typeof(UnityEngine.Debug);
          //注册成员方法等
          Utils.BeginObjectRegister(type, L, translator, 0, 0, 0, 0);
          Utils.EndObjectRegister(type, L, translator, null, null,null, null, null);
          //注册类方法等即Static
          Utils.BeginClassRegister(type, L, __CreateInstance, 17, 3, 1);
          ...
          //注册一个名为Log的回调
          Utils.CLS_IDX(L, Utils.CLS_IDX, "Log", _m_Log_xlua_st_);
          ...
          Utils.EndClassRegister(type, L, translator);
     }



    [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
    static int _m_Log_xlua_st_(RealStatePtr L)
    {
        //根据Log方法的参数数量来生成各种调用
       try {
          ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);
          int gen_param_count = LuaAPI.lua_gettop(L);
          if(gen_param_count == 1&& translator.Assignable<object>(L, 1))
          {
              object _message = translator.GetObject(L, 1, typeof(object));
              UnityEngine.Debug.Log( _message );
              return 0;
          }
          if(gen_param_count == 2&& translator.Assignable<object>(L, 1)&& translator.Assignable<UnityEngine.Object>(L, 2))
          {
              object _message = translator.GetObject(L, 1, typeof(object));
              UnityEngine.Object _context = (UnityEngine.Object)translator.GetObject(L, 2, typeof(UnityEngine.Object));
              UnityEngine.Debug.Log( _message, _context );
              return 0;
          }
 
      } catch(System.Exception gen_e) {
          return LuaAPI.luaL_error(L, "c# exception:" + gen_e);
      }
      return LuaAPI.luaL_error(L, "invalid arguments to UnityEngine.Debug.Log!");
   }
}
注册代码如下
Utils.cs
public static void RegisterFunc(RealStatePtr L, int idx, string name, LuaCSFunction func)
{
  //这里的idx指的是就是CLS_IDX,就是cls_table,也就是SetCSTable设置的表
   idx = abs_idx(LuaAPI.lua_gettop(L), idx);
   //压入方法名
   LuaAPI.xlua_pushasciistring(L, name);
   //压入C#委托指针
   LuaAPI.lua_pushstdcallcfunction(L, func);
   LuaAPI.lua_rawset(L, idx);
}
```

***使用反射式调用***：

```c#
static int FixCSFunction(RealStatePtr L)
{
    try
    {
        ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);
        //这边获取闭包中的upvalue值
        int idx = LuaAPI.xlua_tointeger(L, LuaAPI.xlua_upvalueindex(1));
        //GetFixCSFunction很简单就是return fix_cs_functions[index]; 
        //fix_cs_functions这个是在PushFixCSFunction时候添加的,PushFixCSFunction是在之前ReflectionWrap中调用的
        LuaCSFunction func = (LuaCSFunction)translator.GetFixCSFunction(idx);
        return func(L);
    }
    catch (Exception e)
    {
        return LuaAPI.luaL_error(L, "c# exception in FixCSFunction:" + e);
    }
}
```

当DoString到CS.UnityEngine.Debug.Log("hello world")时候，先从CS.UnityEngine.Debug[Log]获取到对应的value，在lua中这个值是一个function，那么就执行call，压入参数然后就开始调用了。如果是生成是适配代码的方式的话其对应的C#委托就是 _m_Log_xlua_st_(RealStatePtr L)了。但是如果是反射式调用的话,其对应的C#委托永远都是StaticLuaCallbacks.FixCSFunctionWraper这个委托，就是上面代码的FixCSFunction。当调用FixCSFunction后会从中取出upvalue，这个值是一个数字，是个索引。索引的是之前生成wrap时候缓存的方法。然后直接进行调用。