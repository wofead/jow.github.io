# ECS框架的学习

由于最近项目使用了ECS框架，虽然之前就知道这个框架非常厉害，之前做的游戏也有使用，但是当时的使用的模块有限，自己没有怎么接触（还是自己懒），现在游戏全面使用了ECS框架，所以这里捡起来重新好好的理解一番，然后做做功课，发现自己需要学习的东西还有很多，热爱然后努力自己才能够十足的进步。

下面的理解来自云大的blog，blog内容都很高深，每次过去就是看个热闹，懂了几分，真的是个大大的问号，还是自己基础不够牢靠，实践太少的原因，自己应该多学习，多实践。

附上链接：https://blog.codingnow.com/2017/06/overwatch_ecs.html

Entity Component System (ECS) 是一个 gameplay 层面的框架，它是建立在渲染引擎、物理引擎之上的，主要解决的问题是如何建立一个模型来处理游戏对象 (Game Object) 的更新操作。

在我们传统的做游戏中，游戏的对象其实是很多部分聚合而成，引擎的功能模块很多，不同的模块关注的部分往往互不相关。这会导致模块的内聚性很差、模块间也会出现很不必要的耦合。

ECS中的E，即Entity，可以说是传统引擎中的Game Object。这个系统中，它仅仅是C/Component的组合。它的意义在于生命期的管理，这里使用32 ID而不是指针表示的，另外附着了渲染用到的资源ID。因为仅仅负责生命期管理，而不是设计调用其上的方法，用整数ID更健壮。整数ID更容易指代一个无效的对象，而指针就很难做到。

C和S是这个框架的核心。System系统，也就是上面提到的模块。对于游戏来说，每个模块应该专注于干好意见事，而每件事要么是作用于游戏世界里同类的一组对象的每单个个体的，要么是关心这类对象的某种特定的交互行为。

在 ECS 框架中，把每个可能单独使用的对象属性归纳为一个个 Component ，比如对象的名字就是一个 Component ，对象的位置状态是另一个 Component 。每个 Entity 是由多个 Component 组合而成，共享一个生命期；而 Component 之间可以组合在一起作为 System 筛选的标准。

游戏的业务循环就是在调用很多不同的系统，每个系统自己遍历自己感兴趣的对象，只有预定义的组件部分可以被子系统感知到，这样每个系统就能具备很强的内聚性。

ECS 的设计就是为了管理复杂度，它提供的指导方案就是 Component 是纯数据组合，没有任何操作这个数据的方法；而 System 是纯方法组合，它自己没有内部状态。它要么做成无副作用的纯函数，根据它所能见到的对象 Component 组合计算出某种结果；要么用来更新特定 Component 的状态。System 之间也不需要相互调用（减少耦合），是由游戏世界（外部框架）来驱动若干 System 的。

每个 System 都可以独立开发，它只需要遍历给框架提供给它的组件集合，做出正确的处理，更新组件状态就够了。编写 Gameplay 的人更像是在用胶水粘合这些 System ，他只要清楚每个 System 到底做了什么，操作本身对哪些 Component 造成了影响，正确的书写 System 的更新次序就可以了。一个 System 对大多数 Component 是只读的，只对少量 Component 是会改写的，这个可以预先定义清楚，有了这个知识，一是容易管理复杂度，二是给并行处理留下了优化空间。

比如在一开始，他们认为 Component 就是大量有某种同类 Entity 属性的集合的筛选器。ECS 框架辅助这个筛选过程，每个 System 模块都用 for each 的方式迭代相关的 Entity 中对象的组件。之后他们发现，其实对于每个游戏对象集合体来说，一类 Component 可以也应该只有一个。比如存放玩家键盘输入的 Component ，就没有多个。很多 System 都需要去读这个唯一的 Component 内的状态（哪些按钮被按下了），可以安排一个 System 来更新这个 Component 。原文把这种 Component 成为 Singleton Component 。

我们的确还是可以创建一个叫做玩家键盘的 Entity 加到游戏世界中，这个 Entity 是由键盘组件构成。但是我们完全不必迭代玩家键盘这个 Entity 集合，因为它肯定只有一个，直接把这个对象放在游戏世界中即可。但把它放在 System 中就不是一个好设计了。因为它破坏了 System 无状态的设计原则，而且也不支持多个游戏世界。

处理复杂问题的常用方法：

Component 没有方法，而 System 则没有状态，只是对定义好的 Component 状态的加工过程。而许多 System 中很可能会处理同一类问题，涉及的 Component 类型是相同的。如果这个有共性的问题只涉及一个 Entity ，那么直观的方法是设计一个 System ，迭代，逐个把结果计算出来，存为 Component 的状态，别的 System 可以在后续把这个结果作为一个状态读出来就可以了。

但如果这个行为涉及多个 Entity ，比如在不同的 System 中，都需要查询两个 Entity 的敌对关系。我们不可能用一个 System 计算出所有 Entity 间的敌对关系，这样必然产生了大量不必要的计算；又或者这个行为并不想额外修改 Component 的状态，希望对它保持无副作用，比如我想持续模拟一个对象随时间流逝的位置变化，就不能用一个 System 计算好，再从另一个 System 读出来。

这样，就引入了 Utility 函数的概念，来做上面这种类型的操作，再把 Utility 函数共享给不同的 System 调用。为了降低系统复杂度，就要求要么这种函数是无副作用的，随便怎么调用都没问题，比如上面查询敌对关系的例子；要么就限制调用这种函数的地方，仅在很少的地方调用，由调用者小心的保证副作用的影响，比如上面那个持续位置变化的过程。

如果产生状态改变这种副作用的行为必须存在时，又在很多 System 中都会触发，那么为了减少调用的地方，就需要把真正产生副作用的点集中在一处了。这个技巧就是推迟行为的发生时机。就是把行为发生时需要的状态保存起来，放在队列里，由一个单独的 System 在独立的环节集中处理它们。

守望先锋 是基于 UDP 通讯的，从演讲介绍看，对于 UDP 可能丢包的这个问题，他们处理的简单粗暴：客户端每次都将没有经过服务器确认的包打包在一起发送。由于每个逻辑帧的操作很少，打包在一起也不会超过 MTU 限制。