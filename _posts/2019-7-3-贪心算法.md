---
layout:     post
title:      贪心算法
subtitle:   data structure
date:       2019-7-3
author:     Jow
header-img: img/lua-home-bg-o.jpg
catalog: 	 true 
tags:
    - 数据结构
    - 贪心算法

---

### 目录
1. 活动选择问题


> If you can't win the game, remember what you play game is to make yourself happy. So whatever win or lose you should be happy.

贪心算法的核心就是每次都选择局部最优解，然后将这些解拼起来，这样做可以得到一个比较好的解，但是不一定是最优解。

## 活动选择问题
有一批活动，但是举办活动的位置只有一个地方，我们希望在一定的时间内举行尽可能多的活动。
S = {a1,a2,a3 ... an},对应的si和fi为第i个活动的开始和结束时间，si为闭，fi为开。
我们把活动结束时间从小到大排序：

|i|1|2|3|4|5|6|7|8|9|10|11|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|si|1|3|0|5|3|5|6|8|8|2|12|
|fi|4|5|6|7|9|9|10|11|12|14|16|
寻找最优解，Sij表示在ai活动结束之后，aj活动开始之前的活动集合，我们假设Aij就是这样的一个子集，包含活动ak，最后就有Aij = Aik+ak+Akj。
递归式： c[i,j] = c[i,k] + c[k,j] + 1.
接下来可以通过动态递归算法来求解。

使用贪心算法的时候就直接考虑最先结束的，这样留给其它活动的时间就会多。每次都选择在剩余的时间内最先结束的。
```lua
local s = { 1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12 }
local f = { 4, 5, 6, 7, 9, 9, 10, 11, 12, 14, 16 }
local result = {}
local endTime = -1
for i = 1, #f do
    if s[i] >= endTime then
        table.insert(result, i)
        endTime = f[i]
    end
end
```

这里也可以=考虑使用动态规划，利用递归来求得最优解。
```lua
local s = { 1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12 }
local f = { 4, 5, 6, 7, 9, 9, 10, 11, 12, 14, 16 }
local result = {}
local mem = {}
local findActs = function(i, j)
    local acts = {}
    for k = i + 1, j - 1 do
        if (not f[i] or s[k] >= f[i]) and (not s[j] or f[k] <= s[j]) then
            table.insert(acts, k)
        end
    end
    return acts
end
local Optimal
Optimal = function(i, j)
    if i >= j then
        return 0
    end
    local ks = findActs(i, j)
    local max = 0
    local k = 0
    local a1, a2
    if #ks == 0 then
        a1 = mem[(i + 1) .. j] or Optimal(i + 1, j)
        a2 = mem[i .. (j - 1)] or Optimal(i, j - 1)
        max = math.max(a1, a2)
        mem[i .. j] = max
    else
        for m, v in ipairs(ks) do
            a1 = mem[i .. v] or Optimal(i, v)
            a2 = mem[v .. j] or Optimal(v, j)
            local container = 1 + a1 + a2
            if container > max then
                max = container
                k = v
            end
        end
        mem[i .. j] = max
        table.insert(result, k)
    end
    return max
end

local max = Optimal(0, 12)
```
