---
layout:     post
title:      贪心算法
subtitle:   data structure
date:       2019-7-3
author:     Jow
header-img: img/lua-home-bg-o.jpg
catalog: 	 true 
tags:
    - 数据结构
    - 贪心算法

---

### 目录
1. 钢条切割
2. 如何扩张数据结构
3. 区间树


> If you can't win the game, remember what you play game is to make yourself happy. So whatever win or lose you should be happy.

贪心算法的核心就是每次都选择局部最优解，然后将这些解拼起来，这样做可以得到一个比较好的解，但是不一定是最优解。

动态规划方法通常用来求解最优化问题，我们通常按如下步骤来设计动态规划的算法：
1. 刻画一个最优解的结构特征
2. 递归的定义最优解的值
3. 计算最优解的值 ，通常采用自底向上的方法
4. 利用计算出的信息构造一个最优解

可以使用的递归的方法进行求解:
每次求解的都是最优子问题，然后进行判断，最后得到结果，但是通过递归发现每次都需要从顶到底进行递归，时间复杂度为2的n次方。
```lua
local arr = { 1, 5, 8, 9, 10, 17, 17, 20, 24, 30 }
local cutRod
cutRod = function(p, n)
    if n == 0 then
        return 0
    end
    local q = math.mininteger
    for i = 1, n do
        q = math.max(q, p[i] + cutRod(p, n - i))
    end
    return q
end

print(cutRod(arr, 7))
```

所以对上面的问题进行备忘录的添加，每次求得最小子问题的最优解之后进行存储，然后直接使用即可。

```lua
local arr = { 1, 5, 8, 9, 10, 17, 17, 20, 24, 30, 31, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43 }
local r = {}
r[0] = 0
for i, v in ipairs(arr) do
    table.insert(r, math.mininteger)
end
local cutRod
cutRod = function(p, n)
    if n == 0 then
        return 0
    end
    local q = math.mininteger
    for i = 1, n do
        if r[n - i] >= 0 then
            q = math.max(q, p[i] + r[n - i])
        else
            q = math.max(q, p[i] + cutRod(p, n - i))
        end
    end
    r[n] = q
    return q
end
```
