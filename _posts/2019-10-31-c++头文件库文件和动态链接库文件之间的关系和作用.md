---
layout:     post
title:      .h（头文件） .lib（库文件） .dll（动态链接库文件） 之间的关系和作用的区分
subtitle:   c++库文件的理解
date:       2019-10-31
author:     Jow
header-img: img/about-bg-walle.jpg
catalog: 	 true 
tags:
    - c++

---

### 目录
1. 简介
2. 静态链接库(Lib)与动态链接库(DLL)的区别 
3. 例子


> 认真学习，增强自己的能力和知识面。


## 简介

.h头文件是编译时必须的，lib是链接时需要的，dll是运行时需要的。

附加依赖项的是.lib不是.dll，若生成了dll，则肯定也生成了lib文件。如果完成源代码的编译和链接，有头文件和lib就够了。如果也是用动态链接的程序运行起来，有dll就够了(放在debug文件夹中)。在开发和调试阶段，当然最好都有。

.h .lib .dll三者的关系是：

H文件的作用是：声明函数接口。

DLL文件的作用是：函数可执行代码。

当我们在自己的程序中引用了一个H文件里的函数，编链器怎么知道该调用是那个dll文件呢？这就是lib文件的作用：告诉链接器调用的函数在那个dll中，函数执行代码在dll中的什么位置，这也就是为什么需要附加依赖项lib文件，它起到桥梁的作用，如果生成静态库文件，则没有dll，只用lib，这时函数可执行代码部分也在lib文件中。

目前以lib后缀的库有两种，一种为**静态链接库**(Static Libary，以下简称“静态库”)，另一种是**动态链接库**（DLL，以下简称“动态库”）的导入库(Import Libary，以下简称“导入库”）。静态库是一个或者多个obj文件的打包，所以有人干脆把从obj文件生成lib的过程称为Archive，即合并到一起。比如你链接一个静态库，如果其中有错，它会准确的找到是哪个obj有错，即静态lib只是壳子。动态库一般会有对应的导入库，方便程序静态载入动态链接库，否则你可能就需要自己LoadLibary调入DLL文件，然后再手工GetProcAddress获得对应函数了。有了导入库，你只需要链接导入库后按照头文件函数接口的声明调用函数就可以了。导入库和静态库的区别很大，他们实质是不一样的东西。静态库本身就包含了实际执行代码、符号表等等，而对于导入库而言，其实际的执行代码位于动态库中，导入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息。

一般的动态库程序有lib文件和dll文件。lib文件是必须在编译期就连接到应用程序中的，而dll文件是运行期才会被调用的。如果有dll文件，那么对应的lib文件一般是一些索引信息，具体的实现在dll文件中。如果只有lib文件，那么这个lib文件是静态编译出来的，索引和实现都在其中。静态编译的lib文件有好处：给用户安装时就不需要再挂动态库了。但也有缺点，就是导致应用程序比较大，而且失去了动态库的灵活性，在版本升级时，同时要发布新的应用程序才行。在动态库的情况下，有两个文件，而一个是引入库（.LIB）文件，一个是DLL文件，引入库文件包含被DLL导出的函数的名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到所需要使用的DLL文件，库中的函数和数据并不复制到可执行文件中，因此在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中所要调用的函数的内存地址，这样当一个或多个应用程序运行是再把程序代码和被调用的函数代码链接起来，从而节省了内存资源。从上面的说明可以看出，DLL和.LIB文件必须随应用程序一起发行，否则应用程序将会产生错误。

## 静态链接库(Lib)与动态链接库(DLL)的区别 

 静态连接库就是把(lib)文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件；动态链接就是把调用的函数所在文件模块（DLL）和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从DLL中寻找相应函数代码，因此需要相应DLL文件的支持。

静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib 中的指令都全部被直接包含在最终生成的 EXE 文件中了。但是若使用 DLL，该 DLL 不必被包含在最终 EXE 文件中，EXE 文件执行时可以“动态”地引用和卸载这个与 EXE 独立的 DLL 文件。静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。

“每一个lib文件就是若干函数（假设只有函数）的定义” ：

lib库有两种，一种是包含了函数所在DLL文件和文件中函数位置的信息，称为导出库；一种是包含函数代码本身，一般现有的DLL，用的是前一种库；以前在DOS下的TC/BC等，是后一种库。包含函数原型声明的，是头文件（.h）。 

“通过#include包含这些函数声明的头文件后，我们的应用程序就可以使用lib文件中的函数”

还要指定编译器链接相应的库文件。在IDE环境下，一般是一次指定所有用到的库文件，编译器自己寻找每个模块需要的库；在命令行编译环境下，需要指定每个模块调用的库。 

“那他和直接给出那个函数定义的文件，比如.cpp文件，和头文件有什么区别，静态链接库有什么用” 

cpp文件是源代码，库文件是编译后的二进制代码，比如你可以调用Windows的API，但是不能看到其源代码一样。 

“还有不明白的是，静态链接库中的lib文件只要用到，则整个lib文件的内容都放进了exe文件中，那它是被编译进去还是链接的时候连接进去的呢?” 

是在链接的时候将lib链接到目标代码中。

## 例子
在这里测试和学习一下如何使用自己编译出来的库文件，首先创建一个空项目，然后在项目的属性中设置生成lib静态库文件，库文件代码如下：

```c++
// .h文件
#pragma once
#include<iostream>
class LibTest
{
public:
	LibTest();
	void hello();
	int sum(int a, int b);
	~LibTest();
};

//.c++文件
#include "LibTest.h"



LibTest::LibTest()
{
}

void LibTest::hello()
{
	std::cout << "Hello world!" << std::endl;
}

int LibTest::sum(int a, int b) {
	return a + b;
}

LibTest::~LibTest()
{
}

```

之后引用生成的库文件，需要在项目中设置库文件目录和包含目录。

```c++
#include<iostream>
#include<LibTest.h>

#pragma comment(lib,"libStudy.lib")
int main()
{
	LibTest libtest;
	libtest.hello();
	std::cout << libtest.sum(1, 2) << std::endl;
}
```